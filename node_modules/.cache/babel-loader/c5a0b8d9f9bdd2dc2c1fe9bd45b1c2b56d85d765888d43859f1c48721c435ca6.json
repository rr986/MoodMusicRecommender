{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { getFunctionName } from \"../server/api.js\";\nimport { parseArgs, validateDeploymentUrl } from \"../common/index.js\";\nimport { version } from \"../index.js\";\nimport { ConvexError, convexToJson, jsonToConvex } from \"../values/index.js\";\nimport { logToConsole } from \"./logging.js\";\nexport const STATUS_CODE_OK = 200;\nexport const STATUS_CODE_BAD_REQUEST = 400;\nexport const STATUS_CODE_UDF_FAILED = 560;\nlet specifiedFetch = void 0;\nexport function setFetch(f) {\n  specifiedFetch = f;\n}\nexport class ConvexHttpClient {\n  /**\n   * Create a new {@link ConvexHttpClient}.\n   *\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param skipConvexDeploymentUrlCheck - Skip validating that the Convex deployment URL looks like\n   * `https://happy-animal-123.convex.cloud` or localhost. This can be useful if running a self-hosted\n   * Convex backend that uses a different URL.\n   */\n  constructor(address, skipConvexDeploymentUrlCheck) {\n    __publicField(this, \"address\");\n    __publicField(this, \"auth\");\n    __publicField(this, \"adminAuth\");\n    __publicField(this, \"encodedTsPromise\");\n    __publicField(this, \"debug\");\n    __publicField(this, \"fetchOptions\");\n    if (skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    this.address = address;\n    this.debug = true;\n  }\n  /**\n   * Obtain the {@link ConvexHttpClient}'s URL to its backend.\n   * @deprecated Use url, which returns the url without /api at the end.\n   *\n   * @returns The URL to the Convex backend, including the client's API version.\n   */\n  backendUrl() {\n    return `${this.address}/api`;\n  }\n  /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */\n  get url() {\n    return this.address;\n  }\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   *\n   * Should be called whenever the token changes (i.e. due to expiration and refresh).\n   *\n   * @param value - JWT-encoded OpenID Connect identity token.\n   */\n  setAuth(value) {\n    this.clearAuth();\n    this.auth = value;\n  }\n  /**\n   * @internal\n   */\n  setAdminAuth(token, actingAsIdentity) {\n    this.clearAuth();\n    if (actingAsIdentity !== void 0) {\n      const bytes = new TextEncoder().encode(JSON.stringify(actingAsIdentity));\n      const actingAsIdentityEncoded = btoa(String.fromCodePoint(...bytes));\n      this.adminAuth = `${token}:${actingAsIdentityEncoded}`;\n    } else {\n      this.adminAuth = token;\n    }\n  }\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.auth = void 0;\n    this.adminAuth = void 0;\n  }\n  /**\n   * Sets whether the result log lines should be printed on the console or not.\n   *\n   * @internal\n   */\n  setDebug(debug) {\n    this.debug = debug;\n  }\n  /**\n   * Used to customize the fetch behavior in some runtimes.\n   *\n   * @internal\n   */\n  setFetchOptions(fetchOptions) {\n    this.fetchOptions = fetchOptions;\n  }\n  /**\n   * This API is experimental: it may change or disappear.\n   *\n   * Execute a Convex query function at the same timestamp as every other\n   * consistent query execution run by this HTTP client.\n   *\n   * This doesn't make sense for long-lived ConvexHttpClients as Convex\n   * backends can read a limited amount into the past: beyond 30 seconds\n   * in the past may not be available.\n   *\n   * Create a new client to use a consistent time.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   *\n   * @deprecated This API is experimental: it may change or disappear.\n   */\n  async consistentQuery(query) {\n    const queryArgs = parseArgs(arguments.length <= 1 ? undefined : arguments[1]);\n    const timestampPromise = this.getTimestamp();\n    return await this.queryInner(query, queryArgs, {\n      timestampPromise\n    });\n  }\n  async getTimestamp() {\n    if (this.encodedTsPromise) {\n      return this.encodedTsPromise;\n    }\n    return this.encodedTsPromise = this.getTimestampInner();\n  }\n  async getTimestampInner() {\n    const localFetch = specifiedFetch || fetch;\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    const response = await localFetch(`${this.address}/api/query_ts`, {\n      ...this.fetchOptions,\n      method: \"POST\",\n      headers,\n      credentials: \"include\"\n    });\n    if (!response.ok) {\n      throw new Error(await response.text());\n    }\n    const {\n      ts\n    } = await response.json();\n    return ts;\n  }\n  /**\n   * Execute a Convex query function.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   */\n  async query(query) {\n    const queryArgs = parseArgs(arguments.length <= 1 ? undefined : arguments[1]);\n    return await this.queryInner(query, queryArgs, {});\n  }\n  async queryInner(query, queryArgs, options) {\n    const name = getFunctionName(query);\n    const args = [convexToJson(queryArgs)];\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const timestamp = options.timestampPromise ? await options.timestampPromise : void 0;\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args,\n      ...(timestamp ? {\n        ts: timestamp\n      } : {})\n    });\n    const endpoint = timestamp ? `${this.address}/api/query_at_ts` : `${this.address}/api/query`;\n    const response = await localFetch(endpoint, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers,\n      credentials: \"include\"\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"query\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== void 0) {\n          throw forwardErrorData(respJSON.errorData, new ConvexError(respJSON.errorMessage));\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n  /**\n   * Execute a Convex mutation function.\n   *\n   * @param name - The name of the mutation.\n   * @param args - The arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the mutation's result.\n   */\n  async mutation(mutation) {\n    const mutationArgs = parseArgs(arguments.length <= 1 ? undefined : arguments[1]);\n    const name = getFunctionName(mutation);\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args: [convexToJson(mutationArgs)]\n    });\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/mutation`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers,\n      credentials: \"include\"\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"mutation\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== void 0) {\n          throw forwardErrorData(respJSON.errorData, new ConvexError(respJSON.errorMessage));\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n  /**\n   * Execute a Convex action function.\n   *\n   * @param name - The name of the action.\n   * @param args - The arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  async action(action) {\n    const actionArgs = parseArgs(arguments.length <= 1 ? undefined : arguments[1]);\n    const name = getFunctionName(action);\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args: [convexToJson(actionArgs)]\n    });\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/action`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers,\n      credentials: \"include\"\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"action\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== void 0) {\n          throw forwardErrorData(respJSON.errorData, new ConvexError(respJSON.errorMessage));\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n  /**\n   * Execute a Convex function of an unknown type.\n   *\n   * @param name - The name of the function.\n   * @param args - The arguments object for the function. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the function's result.\n   *\n   * @internal\n   */\n  async function(anyFunction, componentPath) {\n    const functionArgs = parseArgs(arguments.length <= 2 ? undefined : arguments[2]);\n    const name = typeof anyFunction === \"string\" ? anyFunction : getFunctionName(anyFunction);\n    const body = JSON.stringify({\n      componentPath,\n      path: name,\n      format: \"convex_encoded_json\",\n      args: convexToJson(functionArgs)\n    });\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/function`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers,\n      credentials: \"include\"\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"any\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== void 0) {\n          throw forwardErrorData(respJSON.errorData, new ConvexError(respJSON.errorMessage));\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n}\nfunction forwardErrorData(errorData, error) {\n  error.data = jsonToConvex(errorData);\n  return error;\n}","map":{"version":3,"names":["getFunctionName","parseArgs","validateDeploymentUrl","version","ConvexError","convexToJson","jsonToConvex","logToConsole","STATUS_CODE_OK","STATUS_CODE_BAD_REQUEST","STATUS_CODE_UDF_FAILED","specifiedFetch","setFetch","f","ConvexHttpClient","constructor","address","skipConvexDeploymentUrlCheck","__publicField","debug","backendUrl","url","setAuth","value","clearAuth","auth","setAdminAuth","token","actingAsIdentity","bytes","TextEncoder","encode","JSON","stringify","actingAsIdentityEncoded","btoa","String","fromCodePoint","adminAuth","setDebug","setFetchOptions","fetchOptions","consistentQuery","query","queryArgs","arguments","length","undefined","timestampPromise","getTimestamp","queryInner","encodedTsPromise","getTimestampInner","localFetch","fetch","headers","response","method","credentials","ok","Error","text","ts","json","options","name","args","timestamp","body","path","format","endpoint","status","respJSON","line","logLines","errorData","forwardErrorData","errorMessage","mutation","mutationArgs","action","actionArgs","function","anyFunction","componentPath","functionArgs","error","data"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/browser/http_client.ts"],"sourcesContent":["import {\n  FunctionReference,\n  FunctionReturnType,\n  OptionalRestArgs,\n  getFunctionName,\n} from \"../server/api.js\";\nimport { parseArgs, validateDeploymentUrl } from \"../common/index.js\";\nimport { version } from \"../index.js\";\nimport {\n  ConvexError,\n  JSONValue,\n  convexToJson,\n  jsonToConvex,\n} from \"../values/index.js\";\nimport { logToConsole } from \"./logging.js\";\nimport { FunctionArgs, UserIdentityAttributes } from \"../server/index.js\";\n\nexport const STATUS_CODE_OK = 200;\nexport const STATUS_CODE_BAD_REQUEST = 400;\n// Special custom 5xx HTTP status code to mean that the UDF returned an error.\n//\n// Must match the constant of the same name in the backend.\nexport const STATUS_CODE_UDF_FAILED = 560;\n\n// Allow fetch to be shimmed in for Node.js < 18\nlet specifiedFetch: typeof globalThis.fetch | undefined = undefined;\nexport function setFetch(f: typeof globalThis.fetch) {\n  specifiedFetch = f;\n}\n\n/**\n * A Convex client that runs queries and mutations over HTTP.\n *\n * This is appropriate for server-side code (like Netlify Lambdas) or non-reactive\n * webapps.\n *\n * If you're building a React app, consider using\n * {@link react.ConvexReactClient} instead.\n *\n * @public\n */\nexport class ConvexHttpClient {\n  private readonly address: string;\n  private auth?: string;\n  private adminAuth?: string;\n  private encodedTsPromise?: Promise<string>;\n  private debug: boolean;\n  private fetchOptions?: FetchOptions;\n\n  /**\n   * Create a new {@link ConvexHttpClient}.\n   *\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param skipConvexDeploymentUrlCheck - Skip validating that the Convex deployment URL looks like\n   * `https://happy-animal-123.convex.cloud` or localhost. This can be useful if running a self-hosted\n   * Convex backend that uses a different URL.\n   */\n  constructor(address: string, skipConvexDeploymentUrlCheck?: boolean) {\n    if (skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    this.address = address;\n    this.debug = true;\n  }\n\n  /**\n   * Obtain the {@link ConvexHttpClient}'s URL to its backend.\n   * @deprecated Use url, which returns the url without /api at the end.\n   *\n   * @returns The URL to the Convex backend, including the client's API version.\n   */\n  backendUrl(): string {\n    return `${this.address}/api`;\n  }\n\n  /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */\n  get url() {\n    return this.address;\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   *\n   * Should be called whenever the token changes (i.e. due to expiration and refresh).\n   *\n   * @param value - JWT-encoded OpenID Connect identity token.\n   */\n  setAuth(value: string) {\n    this.clearAuth();\n    this.auth = value;\n  }\n\n  /**\n   * @internal\n   */\n  setAdminAuth(token: string, actingAsIdentity?: UserIdentityAttributes) {\n    this.clearAuth();\n    if (actingAsIdentity !== undefined) {\n      // Encode the identity to a base64 string\n      const bytes = new TextEncoder().encode(JSON.stringify(actingAsIdentity));\n      const actingAsIdentityEncoded = btoa(String.fromCodePoint(...bytes));\n      this.adminAuth = `${token}:${actingAsIdentityEncoded}`;\n    } else {\n      this.adminAuth = token;\n    }\n  }\n\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.auth = undefined;\n    this.adminAuth = undefined;\n  }\n\n  /**\n   * Sets whether the result log lines should be printed on the console or not.\n   *\n   * @internal\n   */\n  setDebug(debug: boolean) {\n    this.debug = debug;\n  }\n\n  /**\n   * Used to customize the fetch behavior in some runtimes.\n   *\n   * @internal\n   */\n  setFetchOptions(fetchOptions: FetchOptions) {\n    this.fetchOptions = fetchOptions;\n  }\n\n  /**\n   * This API is experimental: it may change or disappear.\n   *\n   * Execute a Convex query function at the same timestamp as every other\n   * consistent query execution run by this HTTP client.\n   *\n   * This doesn't make sense for long-lived ConvexHttpClients as Convex\n   * backends can read a limited amount into the past: beyond 30 seconds\n   * in the past may not be available.\n   *\n   * Create a new client to use a consistent time.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   *\n   * @deprecated This API is experimental: it may change or disappear.\n   */\n  async consistentQuery<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    ...args: OptionalRestArgs<Query>\n  ): Promise<FunctionReturnType<Query>> {\n    const queryArgs = parseArgs(args[0]);\n\n    const timestampPromise = this.getTimestamp();\n    return await this.queryInner(query, queryArgs, { timestampPromise });\n  }\n\n  private async getTimestamp() {\n    if (this.encodedTsPromise) {\n      return this.encodedTsPromise;\n    }\n    return (this.encodedTsPromise = this.getTimestampInner());\n  }\n\n  private async getTimestampInner() {\n    const localFetch = specifiedFetch || fetch;\n\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    const response = await localFetch(`${this.address}/api/query_ts`, {\n      ...this.fetchOptions,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok) {\n      throw new Error(await response.text());\n    }\n    const { ts } = (await response.json()) as { ts: string };\n    return ts;\n  }\n\n  /**\n   * Execute a Convex query function.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   */\n  async query<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    ...args: OptionalRestArgs<Query>\n  ): Promise<FunctionReturnType<Query>> {\n    const queryArgs = parseArgs(args[0]);\n    return await this.queryInner(query, queryArgs, {});\n  }\n\n  private async queryInner<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    queryArgs: FunctionArgs<Query>,\n    options: { timestampPromise?: Promise<string> },\n  ): Promise<FunctionReturnType<Query>> {\n    const name = getFunctionName(query);\n    const args = [convexToJson(queryArgs)];\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n\n    const timestamp = options.timestampPromise\n      ? await options.timestampPromise\n      : undefined;\n\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args,\n      ...(timestamp ? { ts: timestamp } : {}),\n    });\n    const endpoint = timestamp\n      ? `${this.address}/api/query_at_ts`\n      : `${this.address}/api/query`;\n\n    const response = await localFetch(endpoint, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"query\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== undefined) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage),\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n\n  /**\n   * Execute a Convex mutation function.\n   *\n   * @param name - The name of the mutation.\n   * @param args - The arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the mutation's result.\n   */\n  async mutation<Mutation extends FunctionReference<\"mutation\">>(\n    mutation: Mutation,\n    ...args: OptionalRestArgs<Mutation>\n  ): Promise<FunctionReturnType<Mutation>> {\n    const mutationArgs = parseArgs(args[0]);\n    const name = getFunctionName(mutation);\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args: [convexToJson(mutationArgs)],\n    });\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/mutation`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"mutation\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== undefined) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage),\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n\n  /**\n   * Execute a Convex action function.\n   *\n   * @param name - The name of the action.\n   * @param args - The arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  async action<Action extends FunctionReference<\"action\">>(\n    action: Action,\n    ...args: OptionalRestArgs<Action>\n  ): Promise<FunctionReturnType<Action>> {\n    const actionArgs = parseArgs(args[0]);\n    const name = getFunctionName(action);\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args: [convexToJson(actionArgs)],\n    });\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/action`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"action\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== undefined) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage),\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n\n  /**\n   * Execute a Convex function of an unknown type.\n   *\n   * @param name - The name of the function.\n   * @param args - The arguments object for the function. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the function's result.\n   *\n   * @internal\n   */\n  async function<\n    AnyFunction extends FunctionReference<\"query\" | \"mutation\" | \"action\">,\n  >(\n    anyFunction: AnyFunction | string,\n    componentPath?: string,\n    ...args: OptionalRestArgs<AnyFunction>\n  ): Promise<FunctionReturnType<AnyFunction>> {\n    const functionArgs = parseArgs(args[0]);\n    const name =\n      typeof anyFunction === \"string\"\n        ? anyFunction\n        : getFunctionName(anyFunction);\n    const body = JSON.stringify({\n      componentPath: componentPath,\n      path: name,\n      format: \"convex_encoded_json\",\n      args: convexToJson(functionArgs),\n    });\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/function`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"any\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== undefined) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage),\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n}\n\nfunction forwardErrorData(errorData: JSONValue, error: ConvexError<string>) {\n  (error as ConvexError<any>).data = jsonToConvex(errorData);\n  return error;\n}\n\n/**\n * @internal\n */\ntype FetchOptions = { cache: \"force-cache\" | \"no-store\" };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}