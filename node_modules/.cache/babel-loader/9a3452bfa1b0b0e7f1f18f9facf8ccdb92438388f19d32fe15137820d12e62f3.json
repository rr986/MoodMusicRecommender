{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar _a;\nimport { convexToJson, jsonToConvex } from \"../../values/index.js\";\nimport { getFunctionAddress } from \"../impl/actions_impl.js\";\nimport { performAsyncSyscall, performSyscall } from \"../impl/syscall.js\";\nexport const toReferencePath = Symbol.for(\"toReferencePath\");\nexport function extractReferencePath(reference) {\n  return reference[toReferencePath] ?? null;\n}\nexport function isFunctionHandle(s) {\n  return s.startsWith(\"function://\");\n}\nexport async function createFunctionHandle(functionReference) {\n  const address = getFunctionAddress(functionReference);\n  return await performAsyncSyscall(\"1.0/createFunctionHandle\", {\n    ...address\n  });\n}\nclass InstalledComponent {\n  constructor(definition, name) {\n    /**\n     * @internal\n     */\n    __publicField(this, \"_definition\");\n    /**\n     * @internal\n     */\n    __publicField(this, \"_name\");\n    /**\n     * @internal\n     */\n    __publicField(this, _a);\n    this._definition = definition;\n    this._name = name;\n    this[toReferencePath] = `_reference/childComponent/${name}`;\n  }\n  get exports() {\n    return createExports(this._name, []);\n  }\n}\n_a = toReferencePath;\nfunction createExports(name, pathParts) {\n  const handler = {\n    get(_, prop) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createExports(name, newParts);\n      } else if (prop === toReferencePath) {\n        let reference = `_reference/childComponent/${name}`;\n        for (const part of pathParts) {\n          reference += `/${part}`;\n        }\n        return reference;\n      } else {\n        return void 0;\n      }\n    }\n  };\n  return new Proxy({}, handler);\n}\nfunction install(definition) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const importedComponentDefinition = definition;\n  if (typeof importedComponentDefinition.componentDefinitionPath !== \"string\") {\n    throw new Error(\"Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.\");\n  }\n  const name = options.name || importedComponentDefinition.componentDefinitionPath.split(\"/\").pop();\n  this._childComponents.push([name, importedComponentDefinition, options.args ?? {}]);\n  return new InstalledComponent(definition, name);\n}\nfunction installWithInit(definition, options) {\n  const importedComponentDefinition = definition;\n  if (typeof importedComponentDefinition.componentDefinitionPath !== \"string\") {\n    throw new Error(\"Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.\");\n  }\n  const name = options.name || importedComponentDefinition.componentDefinitionPath.split(\"/\").pop();\n  this._childComponents.push([name, importedComponentDefinition, null]);\n  this._onInitCallbacks[name] = s => invokeOnInit(s, options.onInit);\n  return new InstalledComponent(definition, name);\n}\nfunction invokeOnInit(argsStr, onInit) {\n  const argsJson = JSON.parse(argsStr);\n  const args = jsonToConvex(argsJson);\n  const result = onInit({}, args);\n  return JSON.stringify(convexToJson(result));\n}\nfunction mount(exports) {\n  function visit(definition, path, value) {\n    const valueReference = value[toReferencePath];\n    if (valueReference) {\n      if (!path.length) {\n        throw new Error(\"Empty export path\");\n      }\n      let current = definition._exportTree;\n      for (const part of path.slice(0, -1)) {\n        let next = current[part];\n        if (typeof next === \"string\") {\n          throw new Error(`Mount path ${path.join(\".\")} collides with existing export`);\n        }\n        if (!next) {\n          next = {};\n          current[part] = next;\n        }\n        current = next;\n      }\n      const last = path[path.length - 1];\n      if (current[last]) {\n        throw new Error(`Mount path ${path.join(\".\")} collides with existing export`);\n      }\n      current[last] = valueReference;\n    } else {\n      for (const [key, child] of Object.entries(value)) {\n        visit(definition, [...path, key], child);\n      }\n    }\n  }\n  if (exports[toReferencePath]) {\n    throw new Error(`Cannot mount another component's exports at the root`);\n  }\n  visit(this, [], exports);\n}\nfunction mountHttp(pathPrefix, component) {\n  if (!pathPrefix.startsWith(\"/\")) {\n    throw new Error(`Path prefix '${pathPrefix}' does not start with a /`);\n  }\n  if (!pathPrefix.endsWith(\"/\")) {\n    throw new Error(`Path prefix '${pathPrefix}' must end with a /`);\n  }\n  if (this._httpMounts[pathPrefix]) {\n    throw new Error(`Path '${pathPrefix}' is already mounted.`);\n  }\n  const path = extractReferencePath(component);\n  if (!path) {\n    throw new Error(\"`mountHttp` must be called with an `InstalledComponent`.\");\n  }\n  this._httpMounts[pathPrefix] = path;\n}\nfunction exportAppForAnalysis() {\n  const definitionType = {\n    type: \"app\"\n  };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    definitionType,\n    childComponents,\n    httpMounts: this._httpMounts,\n    exports: serializeExportTree(this._exportTree)\n  };\n}\nfunction serializeExportTree(tree) {\n  const branch = [];\n  for (const [key, child] of Object.entries(tree)) {\n    let node;\n    if (typeof child === \"string\") {\n      node = {\n        type: \"leaf\",\n        leaf: child\n      };\n    } else {\n      node = serializeExportTree(child);\n    }\n    branch.push([key, node]);\n  }\n  return {\n    type: \"branch\",\n    branch\n  };\n}\nfunction serializeChildComponents(childComponents) {\n  return childComponents.map(_ref => {\n    let [name, definition, p] = _ref;\n    let args = null;\n    if (p !== null) {\n      args = [];\n      for (const [name2, value] of Object.entries(p)) {\n        if (value !== void 0) {\n          args.push([name2, {\n            type: \"value\",\n            value: JSON.stringify(convexToJson(value))\n          }]);\n        }\n      }\n    }\n    const path = definition.componentDefinitionPath;\n    if (!path) throw new Error(\"no .componentPath for component definition \" + JSON.stringify(definition, null, 2));\n    return {\n      name,\n      path,\n      args\n    };\n  });\n}\nfunction exportComponentForAnalysis() {\n  const args = Object.entries(this._args).map(_ref2 => {\n    let [name, validator] = _ref2;\n    return [name, {\n      type: \"value\",\n      value: JSON.stringify(validator.json)\n    }];\n  });\n  const definitionType = {\n    type: \"childComponent\",\n    name: this._name,\n    args\n  };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    name: this._name,\n    definitionType,\n    childComponents,\n    httpMounts: this._httpMounts,\n    exports: serializeExportTree(this._exportTree)\n  };\n}\nexport function defineComponent(name) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const ret = {\n    _isRoot: false,\n    _name: name,\n    _args: options.args || {},\n    _childComponents: [],\n    _httpMounts: {},\n    _exportTree: {},\n    _onInitCallbacks: {},\n    export: exportComponentForAnalysis,\n    install,\n    installWithInit,\n    mount,\n    mountHttp,\n    // pretend to conform to ComponentDefinition, which temporarily expects __args\n    ...{}\n  };\n  return ret;\n}\nexport function defineApp() {\n  const ret = {\n    _isRoot: true,\n    _childComponents: [],\n    _httpMounts: {},\n    _exportTree: {},\n    export: exportAppForAnalysis,\n    install,\n    mount,\n    mountHttp\n  };\n  return ret;\n}\nexport function currentSystemUdfInComponent(componentId) {\n  return {\n    [toReferencePath]: `_reference/currentSystemUdfInComponent/${componentId}`\n  };\n}\nfunction createChildComponents(root, pathParts) {\n  const handler = {\n    get(_, prop) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createChildComponents(root, newParts);\n      } else if (prop === toReferencePath) {\n        if (pathParts.length < 1) {\n          const found = [root, ...pathParts].join(\".\");\n          throw new Error(`API path is expected to be of the form \\`${root}.childComponent.functionName\\`. Found: \\`${found}\\``);\n        }\n        return `_reference/childComponent/` + pathParts.join(\"/\");\n      } else {\n        return void 0;\n      }\n    }\n  };\n  return new Proxy({}, handler);\n}\nexport function createComponentArg() {\n  return (ctx, name) => {\n    const result = performSyscall(\"1.0/componentArgument\", {\n      name\n    });\n    return jsonToConvex(result).value;\n  };\n}\nexport const componentsGeneric = () => createChildComponents(\"components\", []);","map":{"version":3,"names":["_a","convexToJson","jsonToConvex","getFunctionAddress","performAsyncSyscall","performSyscall","toReferencePath","Symbol","for","extractReferencePath","reference","isFunctionHandle","s","startsWith","createFunctionHandle","functionReference","address","InstalledComponent","constructor","definition","name","__publicField","_definition","_name","exports","createExports","pathParts","handler","get","_","prop","newParts","part","Proxy","install","options","arguments","length","undefined","importedComponentDefinition","componentDefinitionPath","Error","split","pop","_childComponents","push","args","installWithInit","_onInitCallbacks","invokeOnInit","onInit","argsStr","argsJson","JSON","parse","result","stringify","mount","visit","path","value","valueReference","current","_exportTree","slice","next","join","last","key","child","Object","entries","mountHttp","pathPrefix","component","endsWith","_httpMounts","exportAppForAnalysis","definitionType","type","childComponents","serializeChildComponents","httpMounts","serializeExportTree","tree","branch","node","leaf","map","_ref","p","name2","exportComponentForAnalysis","_args","_ref2","validator","json","defineComponent","ret","_isRoot","export","defineApp","currentSystemUdfInComponent","componentId","createChildComponents","root","found","createComponentArg","ctx","componentsGeneric"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/server/components/index.ts"],"sourcesContent":["import {\n  Infer,\n  ObjectType,\n  PropertyValidators,\n  convexToJson,\n  jsonToConvex,\n} from \"../../values/index.js\";\nimport {\n  AnyFunctionReference,\n  FunctionReference,\n  FunctionType,\n} from \"../api.js\";\nimport { getFunctionAddress } from \"../impl/actions_impl.js\";\nimport { performAsyncSyscall, performSyscall } from \"../impl/syscall.js\";\nimport { DefaultFunctionArgs, EmptyObject } from \"../registration.js\";\nimport {\n  AppDefinitionAnalysis,\n  ComponentDefinitionAnalysis,\n  ComponentDefinitionType,\n  HttpMount,\n} from \"./definition.js\";\n\nexport const toReferencePath = Symbol.for(\"toReferencePath\");\n\nexport function extractReferencePath(reference: any): string | null {\n  return reference[toReferencePath] ?? null;\n}\n\nexport function isFunctionHandle(s: string): boolean {\n  return s.startsWith(\"function://\");\n}\n\n/**\n * @internal\n */\nexport type FunctionHandle<\n  Type extends FunctionType,\n  Args extends DefaultFunctionArgs = any,\n  ReturnType = any,\n> = string & FunctionReference<Type, \"internal\", Args, ReturnType>;\n\n/**\n * @internal\n */\nexport async function createFunctionHandle<\n  Type extends FunctionType,\n  Args extends DefaultFunctionArgs,\n  ReturnType,\n>(\n  functionReference: FunctionReference<\n    Type,\n    \"public\" | \"internal\",\n    Args,\n    ReturnType\n  >,\n): Promise<FunctionHandle<Type, Args, ReturnType>> {\n  const address = getFunctionAddress(functionReference);\n  return await performAsyncSyscall(\"1.0/createFunctionHandle\", { ...address });\n}\n\ninterface ComponentExports {\n  [key: string]: FunctionReference<any, any, any, any> | ComponentExports;\n}\n\n/**\n * @internal\n */\nexport interface InitCtx {}\n\n/**\n * An object of this type should be the default export of a\n * convex.config.ts file in a component definition directory.\n *\n * @internal\n */ // eslint-disable-next-line @typescript-eslint/ban-types\nexport type ComponentDefinition<\n  Args extends PropertyValidators = EmptyObject,\n  Exports extends ComponentExports = any,\n> = {\n  /**\n   * Install a component with the given definition in this component definition.\n   *\n   * Takes a component definition, an optional name, and the args it requires.\n   *\n   * For editor tooling this method expects a {@link ComponentDefinition}\n   * but at runtime the object that is imported will be a {@link ImportedComponentDefinition}\n   */\n  install<Definition extends ComponentDefinition<any, any>>(\n    definition: Definition,\n    options: {\n      name?: string;\n      // TODO we have to do the \"arguments are optional if empty, otherwise required\"\n      args?: ObjectType<ComponentDefinitionArgs<Definition>>;\n    },\n  ): InstalledComponent<Definition>;\n\n  installWithInit<Definition extends ComponentDefinition<any, any>>(\n    definition: Definition,\n    options: {\n      name?: string;\n      onInit: (\n        ctx: InitCtx,\n        args: ObjectType<Args>,\n      ) => ObjectType<ComponentDefinitionArgs<Definition>>;\n    },\n  ): InstalledComponent<Definition>;\n\n  mount(exports: ComponentExports): void;\n\n  /**\n   * Mount a component's HTTP router at a given path prefix.\n   */\n  mountHttp(pathPrefix: string, component: InstalledComponent<any>): void;\n\n  // TODO this will be needed once components are responsible for building interfaces for themselves\n  /**\n   * @internal\n   */\n  __args: Args;\n\n  /**\n   * @internal\n   */\n  __exports: Exports;\n};\n\ntype ComponentDefinitionArgs<T extends ComponentDefinition<any, any>> =\n  T[\"__args\"];\ntype ComponentDefinitionExports<T extends ComponentDefinition<any, any>> =\n  T[\"__exports\"];\n\n/**\n * An object of this type should be the default export of a\n * convex.config.ts file in a component-aware convex directory.\n *\n * @internal\n */\nexport type AppDefinition = {\n  /**\n   * Install a component with the given definition in this component definition.\n   *\n   * Takes a component definition, an optional name, and the args it requires.\n   *\n   * For editor tooling this method expects a {@link ComponentDefinition}\n   * but at runtime the object that is imported will be a {@link ImportedComponentDefinition}\n   */\n  install<Definition extends ComponentDefinition<any, any>>(\n    definition: Definition,\n    options: {\n      name?: string;\n      args?: ObjectType<ComponentDefinitionArgs<Definition>>;\n    },\n  ): InstalledComponent<Definition>;\n\n  mount(exports: ComponentExports): void;\n\n  /**\n   * Mount a component's HTTP router at a given path prefix.\n   */\n  mountHttp(pathPrefix: string, component: InstalledComponent<any>): void;\n};\n\ninterface ExportTree {\n  // Tree with serialized `Reference`s as leaves.\n  [key: string]: string | ExportTree;\n}\n\ntype CommonDefinitionData = {\n  _isRoot: boolean;\n  _childComponents: [\n    string,\n    ImportedComponentDefinition,\n    Record<string, any> | null,\n  ][];\n  _httpMounts: Record<string, HttpMount>;\n  _exportTree: ExportTree;\n};\n\ntype ComponentDefinitionData = CommonDefinitionData & {\n  _args: PropertyValidators;\n  _name: string;\n  _onInitCallbacks: Record<string, (argsStr: string) => string>;\n};\ntype AppDefinitionData = CommonDefinitionData;\n\n/**\n * Used to refer to an already-installed component.\n */\nclass InstalledComponent<Definition extends ComponentDefinition<any, any>> {\n  /**\n   * @internal\n   */\n  _definition: Definition;\n\n  /**\n   * @internal\n   */\n  _name: string;\n\n  /**\n   * @internal\n   */\n  [toReferencePath]: string;\n\n  constructor(definition: Definition, name: string) {\n    this._definition = definition;\n    this._name = name;\n    this[toReferencePath] = `_reference/childComponent/${name}`;\n  }\n\n  get exports(): ComponentDefinitionExports<Definition> {\n    return createExports(this._name, []);\n  }\n}\n\nfunction createExports(name: string, pathParts: string[]): any {\n  const handler: ProxyHandler<any> = {\n    get(_, prop: string | symbol) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createExports(name, newParts);\n      } else if (prop === toReferencePath) {\n        let reference = `_reference/childComponent/${name}`;\n        for (const part of pathParts) {\n          reference += `/${part}`;\n        }\n        return reference;\n      } else {\n        return undefined;\n      }\n    },\n  };\n  return new Proxy({}, handler);\n}\n\nfunction install<Definition extends ComponentDefinition<any>>(\n  this: CommonDefinitionData,\n  definition: Definition,\n  options: {\n    name?: string;\n    args?: Infer<ComponentDefinitionArgs<Definition>>;\n  } = {},\n): InstalledComponent<Definition> {\n  // At runtime an imported component will have this shape.\n  const importedComponentDefinition =\n    definition as unknown as ImportedComponentDefinition;\n  if (typeof importedComponentDefinition.componentDefinitionPath !== \"string\") {\n    throw new Error(\n      \"Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.\",\n    );\n  }\n  const name =\n    options.name ||\n    importedComponentDefinition.componentDefinitionPath.split(\"/\").pop()!;\n  this._childComponents.push([\n    name,\n    importedComponentDefinition,\n    options.args ?? {},\n  ]);\n  return new InstalledComponent(definition, name);\n}\n\nfunction installWithInit<Definition extends ComponentDefinition<any>>(\n  this: ComponentDefinitionData,\n  definition: Definition,\n  options: {\n    name?: string;\n    onInit: (ctx: InitCtx, args: any) => any;\n  },\n): InstalledComponent<Definition> {\n  // At runtime an imported component will have this shape.\n  const importedComponentDefinition =\n    definition as unknown as ImportedComponentDefinition;\n  if (typeof importedComponentDefinition.componentDefinitionPath !== \"string\") {\n    throw new Error(\n      \"Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.\",\n    );\n  }\n  const name =\n    options.name ||\n    importedComponentDefinition.componentDefinitionPath.split(\"/\").pop()!;\n  this._childComponents.push([name, importedComponentDefinition, null]);\n  this._onInitCallbacks[name] = (s) => invokeOnInit(s, options.onInit);\n  return new InstalledComponent(definition, name);\n}\n\nfunction invokeOnInit(\n  argsStr: string,\n  onInit: (ctx: InitCtx, args: any) => any,\n): string {\n  const argsJson = JSON.parse(argsStr);\n  const args = jsonToConvex(argsJson);\n  const result = onInit({}, args);\n  return JSON.stringify(convexToJson(result));\n}\n\nfunction mount(this: CommonDefinitionData, exports: any) {\n  function visit(definition: CommonDefinitionData, path: string[], value: any) {\n    const valueReference = value[toReferencePath];\n    if (valueReference) {\n      if (!path.length) {\n        throw new Error(\"Empty export path\");\n      }\n      let current = definition._exportTree;\n      for (const part of path.slice(0, -1)) {\n        let next = current[part];\n        if (typeof next === \"string\") {\n          throw new Error(\n            `Mount path ${path.join(\".\")} collides with existing export`,\n          );\n        }\n        if (!next) {\n          next = {};\n          current[part] = next;\n        }\n        current = next;\n      }\n      const last = path[path.length - 1];\n      if (current[last]) {\n        throw new Error(\n          `Mount path ${path.join(\".\")} collides with existing export`,\n        );\n      }\n      current[last] = valueReference;\n    } else {\n      for (const [key, child] of Object.entries(value)) {\n        visit(definition, [...path, key], child);\n      }\n    }\n  }\n  if (exports[toReferencePath]) {\n    throw new Error(`Cannot mount another component's exports at the root`);\n  }\n  visit(this, [], exports);\n}\n\nfunction mountHttp(\n  this: CommonDefinitionData,\n  pathPrefix: string,\n  component: InstalledComponent<any>,\n) {\n  if (!pathPrefix.startsWith(\"/\")) {\n    throw new Error(`Path prefix '${pathPrefix}' does not start with a /`);\n  }\n  if (!pathPrefix.endsWith(\"/\")) {\n    throw new Error(`Path prefix '${pathPrefix}' must end with a /`);\n  }\n  if (this._httpMounts[pathPrefix]) {\n    throw new Error(`Path '${pathPrefix}' is already mounted.`);\n  }\n  const path = extractReferencePath(component);\n  if (!path) {\n    throw new Error(\"`mountHttp` must be called with an `InstalledComponent`.\");\n  }\n  this._httpMounts[pathPrefix] = path;\n}\n\n// At runtime when you import a ComponentDefinition, this is all it is\n/**\n * @internal\n */\nexport type ImportedComponentDefinition = {\n  componentDefinitionPath: string;\n};\n\nfunction exportAppForAnalysis(\n  this: ComponentDefinition<any> & AppDefinitionData,\n): AppDefinitionAnalysis {\n  const definitionType = { type: \"app\" as const };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    definitionType,\n    childComponents: childComponents as any,\n    httpMounts: this._httpMounts,\n    exports: serializeExportTree(this._exportTree),\n  };\n}\n\nfunction serializeExportTree(tree: ExportTree): any {\n  const branch: any[] = [];\n  for (const [key, child] of Object.entries(tree)) {\n    let node;\n    if (typeof child === \"string\") {\n      node = { type: \"leaf\", leaf: child };\n    } else {\n      node = serializeExportTree(child);\n    }\n    branch.push([key, node]);\n  }\n  return { type: \"branch\", branch };\n}\n\nfunction serializeChildComponents(\n  childComponents: [\n    string,\n    ImportedComponentDefinition,\n    Record<string, any> | null,\n  ][],\n): {\n  name: string;\n  path: string;\n  args: [string, { type: \"value\"; value: string }][] | null;\n}[] {\n  return childComponents.map(([name, definition, p]) => {\n    let args: [string, { type: \"value\"; value: string }][] | null = null;\n    if (p !== null) {\n      args = [];\n      for (const [name, value] of Object.entries(p)) {\n        if (value !== undefined) {\n          args.push([\n            name,\n            { type: \"value\", value: JSON.stringify(convexToJson(value)) },\n          ]);\n        }\n      }\n    }\n    // we know that components carry this extra information\n    const path = definition.componentDefinitionPath;\n    if (!path)\n      throw new Error(\n        \"no .componentPath for component definition \" +\n          JSON.stringify(definition, null, 2),\n      );\n\n    return {\n      name: name!,\n      path: path!,\n      args,\n    };\n  });\n}\n\nfunction exportComponentForAnalysis(\n  this: ComponentDefinition<any> & ComponentDefinitionData,\n): ComponentDefinitionAnalysis {\n  const args: [string, { type: \"value\"; value: string }][] = Object.entries(\n    this._args,\n  ).map(([name, validator]) => [\n    name,\n    {\n      type: \"value\",\n      value: JSON.stringify(validator.json),\n    },\n  ]);\n  const definitionType: ComponentDefinitionType = {\n    type: \"childComponent\" as const,\n    name: this._name,\n    args,\n  };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    name: this._name,\n    definitionType,\n    childComponents: childComponents as any,\n    httpMounts: this._httpMounts,\n    exports: serializeExportTree(this._exportTree),\n  };\n}\n\n// This is what is actually contained in a ComponentDefinition.\ntype RuntimeComponentDefinition = Omit<\n  ComponentDefinition<any, any>,\n  \"__args\" | \"__exports\"\n> &\n  ComponentDefinitionData & {\n    export: () => ComponentDefinitionAnalysis;\n  };\ntype RuntimeAppDefinition = AppDefinition &\n  AppDefinitionData & {\n    export: () => AppDefinitionAnalysis;\n  };\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function defineComponent<\n  Args extends PropertyValidators = EmptyObject,\n  Exports extends ComponentExports = any,\n>(\n  name: string,\n  options: { args?: Args } = {},\n): ComponentDefinition<Args, Exports> {\n  const ret: RuntimeComponentDefinition = {\n    _isRoot: false,\n    _name: name,\n    _args: options.args || {},\n    _childComponents: [],\n    _httpMounts: {},\n    _exportTree: {},\n    _onInitCallbacks: {},\n\n    export: exportComponentForAnalysis,\n    install,\n    installWithInit,\n    mount,\n    mountHttp,\n\n    // pretend to conform to ComponentDefinition, which temporarily expects __args\n    ...({} as { __args: any; __exports: any }),\n  };\n  return ret as any as ComponentDefinition<Args, Exports>;\n}\n\n/**\n * Experimental - DO NOT USE.\n */\n// TODO Make this not experimental.\nexport function defineApp(): AppDefinition {\n  const ret: RuntimeAppDefinition = {\n    _isRoot: true,\n    _childComponents: [],\n    _httpMounts: {},\n    _exportTree: {},\n\n    export: exportAppForAnalysis,\n    install,\n    mount,\n    mountHttp,\n  };\n  return ret as AppDefinition;\n}\n\ntype AnyInterfaceType = {\n  [key: string]: AnyInterfaceType;\n} & AnyFunctionReference;\nexport type AnyComponentReference = Record<string, AnyInterfaceType>;\n\ntype AnyChildComponents = Record<string, AnyComponentReference>;\n\n/**\n * @internal\n */\nexport function currentSystemUdfInComponent(\n  componentId: string,\n): AnyComponentReference {\n  return {\n    [toReferencePath]: `_reference/currentSystemUdfInComponent/${componentId}`,\n  };\n}\n\nfunction createChildComponents(\n  root: string,\n  pathParts: string[],\n): AnyChildComponents {\n  const handler: ProxyHandler<object> = {\n    get(_, prop: string | symbol) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createChildComponents(root, newParts);\n      } else if (prop === toReferencePath) {\n        if (pathParts.length < 1) {\n          const found = [root, ...pathParts].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`${root}.childComponent.functionName\\`. Found: \\`${found}\\``,\n          );\n        }\n        return `_reference/childComponent/` + pathParts.join(\"/\");\n      } else {\n        return undefined;\n      }\n    },\n  };\n  return new Proxy({}, handler);\n}\n\n/**\n *\n * @internal\n */\nexport function createComponentArg(): (ctx: any, name: string) => any {\n  return (ctx: any, name: string) => {\n    const result = performSyscall(\"1.0/componentArgument\", {\n      name,\n    });\n    return (jsonToConvex(result) as any).value;\n  };\n}\n\n/**\n * @internal\n */\nexport const componentsGeneric = () => createChildComponents(\"components\", []);\n\n/**\n * @internal\n */\nexport type AnyComponents = AnyChildComponents;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}