{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { convexToJson } from \"../values/index.js\";\nimport { getFunctionName } from \"../server/api.js\";\nexport class QueriesObserver {\n  constructor(createWatch) {\n    __publicField(this, \"createWatch\");\n    __publicField(this, \"queries\");\n    __publicField(this, \"listeners\");\n    this.createWatch = createWatch;\n    this.queries = {};\n    this.listeners = /* @__PURE__ */new Set();\n  }\n  setQueries(newQueries) {\n    for (const identifier of Object.keys(newQueries)) {\n      const {\n        query,\n        args\n      } = newQueries[identifier];\n      getFunctionName(query);\n      if (this.queries[identifier] === void 0) {\n        this.addQuery(identifier, query, args);\n      } else {\n        const existingInfo = this.queries[identifier];\n        if (getFunctionName(query) !== getFunctionName(existingInfo.query) || JSON.stringify(convexToJson(args)) !== JSON.stringify(convexToJson(existingInfo.args))) {\n          this.removeQuery(identifier);\n          this.addQuery(identifier, query, args);\n        }\n      }\n    }\n    for (const identifier of Object.keys(this.queries)) {\n      if (newQueries[identifier] === void 0) {\n        this.removeQuery(identifier);\n      }\n    }\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n  getLocalResults(queries) {\n    const result = {};\n    for (const identifier of Object.keys(queries)) {\n      const {\n        query,\n        args\n      } = queries[identifier];\n      getFunctionName(query);\n      const watch = this.createWatch(query, args);\n      let value;\n      try {\n        value = watch.localQueryResult();\n      } catch (e) {\n        if (e instanceof Error) {\n          value = e;\n        } else {\n          throw e;\n        }\n      }\n      result[identifier] = value;\n    }\n    return result;\n  }\n  setCreateWatch(createWatch) {\n    this.createWatch = createWatch;\n    for (const identifier of Object.keys(this.queries)) {\n      const {\n        query,\n        args,\n        watch\n      } = this.queries[identifier];\n      const journal = watch.journal();\n      this.removeQuery(identifier);\n      this.addQuery(identifier, query, args, journal);\n    }\n  }\n  destroy() {\n    for (const identifier of Object.keys(this.queries)) {\n      this.removeQuery(identifier);\n    }\n    this.listeners = /* @__PURE__ */new Set();\n  }\n  addQuery(identifier, query, args, journal) {\n    if (this.queries[identifier] !== void 0) {\n      throw new Error(`Tried to add a new query with identifier ${identifier} when it already exists.`);\n    }\n    const watch = this.createWatch(query, args, journal);\n    const unsubscribe = watch.onUpdate(() => this.notifyListeners());\n    this.queries[identifier] = {\n      query,\n      args,\n      watch,\n      unsubscribe\n    };\n  }\n  removeQuery(identifier) {\n    const info = this.queries[identifier];\n    if (info === void 0) {\n      throw new Error(`No query found with identifier ${identifier}.`);\n    }\n    info.unsubscribe();\n    delete this.queries[identifier];\n  }\n  notifyListeners() {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}","map":{"version":3,"names":["convexToJson","getFunctionName","QueriesObserver","constructor","createWatch","__publicField","queries","listeners","Set","setQueries","newQueries","identifier","Object","keys","query","args","addQuery","existingInfo","JSON","stringify","removeQuery","subscribe","listener","add","delete","getLocalResults","result","watch","value","localQueryResult","e","Error","setCreateWatch","journal","destroy","unsubscribe","onUpdate","notifyListeners","info"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/react/queries_observer.ts"],"sourcesContent":["import { convexToJson, Value } from \"../values/index.js\";\nimport { Watch } from \"./client.js\";\nimport { QueryJournal } from \"../browser/sync/protocol.js\";\nimport { FunctionReference, getFunctionName } from \"../server/api.js\";\n\ntype Identifier = string;\n\ntype QueryInfo = {\n  query: FunctionReference<\"query\">;\n  args: Record<string, Value>;\n  watch: Watch<Value>;\n  unsubscribe: () => void;\n};\n\nexport type CreateWatch = (\n  query: FunctionReference<\"query\">,\n  args: Record<string, Value>,\n  journal?: QueryJournal,\n) => Watch<Value>;\n\n/**\n * A class for observing the results of multiple queries at the same time.\n *\n * Any time the result of a query changes, the listeners are notified.\n */\nexport class QueriesObserver {\n  public createWatch: CreateWatch;\n  private queries: Record<Identifier, QueryInfo>;\n  private listeners: Set<() => void>;\n\n  constructor(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    this.queries = {};\n    this.listeners = new Set();\n  }\n\n  setQueries(\n    newQueries: Record<\n      Identifier,\n      { query: FunctionReference<\"query\">; args: Record<string, Value> }\n    >,\n  ) {\n    // Add the new queries before unsubscribing from the old ones so that\n    // the deduping in the `ConvexReactClient` can help if there are duplicates.\n    for (const identifier of Object.keys(newQueries)) {\n      const { query, args } = newQueries[identifier];\n      // Might throw\n      getFunctionName(query);\n\n      if (this.queries[identifier] === undefined) {\n        // No existing query => add it.\n        this.addQuery(identifier, query, args);\n      } else {\n        const existingInfo = this.queries[identifier];\n        if (\n          getFunctionName(query) !== getFunctionName(existingInfo.query) ||\n          JSON.stringify(convexToJson(args)) !==\n            JSON.stringify(convexToJson(existingInfo.args))\n        ) {\n          // Existing query that doesn't match => remove the old and add the new.\n          this.removeQuery(identifier);\n          this.addQuery(identifier, query, args);\n        }\n      }\n    }\n\n    // Prune all the existing queries that we no longer need.\n    for (const identifier of Object.keys(this.queries)) {\n      if (newQueries[identifier] === undefined) {\n        this.removeQuery(identifier);\n      }\n    }\n  }\n\n  subscribe(listener: () => void): () => void {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  getLocalResults(\n    queries: Record<\n      Identifier,\n      { query: FunctionReference<\"query\">; args: Record<string, Value> }\n    >,\n  ): Record<Identifier, Value | undefined | Error> {\n    const result: Record<Identifier, Value | Error | undefined> = {};\n    for (const identifier of Object.keys(queries)) {\n      const { query, args } = queries[identifier];\n      // Might throw\n      getFunctionName(query);\n\n      // Note: We're not gonna watch, we could save some allocations\n      // by getting a reference to the client directly instead.\n      const watch = this.createWatch(query, args);\n      let value: Value | undefined | Error;\n      try {\n        value = watch.localQueryResult();\n      } catch (e) {\n        // Only collect instances of `Error` because thats how callers\n        // will distinguish errors from normal results.\n        if (e instanceof Error) {\n          value = e;\n        } else {\n          throw e;\n        }\n      }\n      result[identifier] = value;\n    }\n    return result;\n  }\n\n  setCreateWatch(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    // If we have a new watch, we might be using a new Convex client.\n    // Recreate all the watches being careful to preserve the journals.\n    for (const identifier of Object.keys(this.queries)) {\n      const { query, args, watch } = this.queries[identifier];\n      const journal = watch.journal();\n      this.removeQuery(identifier);\n      this.addQuery(identifier, query, args, journal);\n    }\n  }\n\n  destroy() {\n    for (const identifier of Object.keys(this.queries)) {\n      this.removeQuery(identifier);\n    }\n    this.listeners = new Set();\n  }\n\n  private addQuery(\n    identifier: Identifier,\n    query: FunctionReference<\"query\">,\n    args: Record<string, Value>,\n    journal?: QueryJournal,\n  ) {\n    if (this.queries[identifier] !== undefined) {\n      throw new Error(\n        `Tried to add a new query with identifier ${identifier} when it already exists.`,\n      );\n    }\n    const watch = this.createWatch(query, args, journal);\n    const unsubscribe = watch.onUpdate(() => this.notifyListeners());\n    this.queries[identifier] = {\n      query,\n      args,\n      watch,\n      unsubscribe,\n    };\n  }\n\n  private removeQuery(identifier: Identifier) {\n    const info = this.queries[identifier];\n    if (info === undefined) {\n      throw new Error(`No query found with identifier ${identifier}.`);\n    }\n    info.unsubscribe();\n    delete this.queries[identifier];\n  }\n\n  private notifyListeners(): void {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;AAAA,SAASA,YAAA,QAA2B;AAGpC,SAA4BC,eAAA,QAAuB;AAsB5C,aAAMC,eAAA,CAAgB;EAK3BC,YAAYC,WAAA,EAA0B;IAJtCC,aAAA,OAAO;IACPA,aAAA,OAAQ;IACRA,aAAA,OAAQ;IAGN,KAAKD,WAAA,GAAcA,WAAA;IACnB,KAAKE,OAAA,GAAU,CAAC;IAChB,KAAKC,SAAA,GAAY,mBAAIC,GAAA,CAAI;EAC3B;EAEAC,WACEC,UAAA,EAIA;IAGA,WAAWC,UAAA,IAAcC,MAAA,CAAOC,IAAA,CAAKH,UAAU,GAAG;MAChD,MAAM;QAAEI,KAAA;QAAOC;MAAK,IAAIL,UAAA,CAAWC,UAAU;MAE7CV,eAAA,CAAgBa,KAAK;MAErB,IAAI,KAAKR,OAAA,CAAQK,UAAU,MAAM,QAAW;QAE1C,KAAKK,QAAA,CAASL,UAAA,EAAYG,KAAA,EAAOC,IAAI;MACvC,OAAO;QACL,MAAME,YAAA,GAAe,KAAKX,OAAA,CAAQK,UAAU;QAC5C,IACEV,eAAA,CAAgBa,KAAK,MAAMb,eAAA,CAAgBgB,YAAA,CAAaH,KAAK,KAC7DI,IAAA,CAAKC,SAAA,CAAUnB,YAAA,CAAae,IAAI,CAAC,MAC/BG,IAAA,CAAKC,SAAA,CAAUnB,YAAA,CAAaiB,YAAA,CAAaF,IAAI,CAAC,GAChD;UAEA,KAAKK,WAAA,CAAYT,UAAU;UAC3B,KAAKK,QAAA,CAASL,UAAA,EAAYG,KAAA,EAAOC,IAAI;QACvC;MACF;IACF;IAGA,WAAWJ,UAAA,IAAcC,MAAA,CAAOC,IAAA,CAAK,KAAKP,OAAO,GAAG;MAClD,IAAII,UAAA,CAAWC,UAAU,MAAM,QAAW;QACxC,KAAKS,WAAA,CAAYT,UAAU;MAC7B;IACF;EACF;EAEAU,UAAUC,QAAA,EAAkC;IAC1C,KAAKf,SAAA,CAAUgB,GAAA,CAAID,QAAQ;IAC3B,OAAO,MAAM;MACX,KAAKf,SAAA,CAAUiB,MAAA,CAAOF,QAAQ;IAChC;EACF;EAEAG,gBACEnB,OAAA,EAI+C;IAC/C,MAAMoB,MAAA,GAAwD,CAAC;IAC/D,WAAWf,UAAA,IAAcC,MAAA,CAAOC,IAAA,CAAKP,OAAO,GAAG;MAC7C,MAAM;QAAEQ,KAAA;QAAOC;MAAK,IAAIT,OAAA,CAAQK,UAAU;MAE1CV,eAAA,CAAgBa,KAAK;MAIrB,MAAMa,KAAA,GAAQ,KAAKvB,WAAA,CAAYU,KAAA,EAAOC,IAAI;MAC1C,IAAIa,KAAA;MACJ,IAAI;QACFA,KAAA,GAAQD,KAAA,CAAME,gBAAA,CAAiB;MACjC,SAASC,CAAA,EAAP;QAGA,IAAIA,CAAA,YAAaC,KAAA,EAAO;UACtBH,KAAA,GAAQE,CAAA;QACV,OAAO;UACL,MAAMA,CAAA;QACR;MACF;MACAJ,MAAA,CAAOf,UAAU,IAAIiB,KAAA;IACvB;IACA,OAAOF,MAAA;EACT;EAEAM,eAAe5B,WAAA,EAA0B;IACvC,KAAKA,WAAA,GAAcA,WAAA;IAGnB,WAAWO,UAAA,IAAcC,MAAA,CAAOC,IAAA,CAAK,KAAKP,OAAO,GAAG;MAClD,MAAM;QAAEQ,KAAA;QAAOC,IAAA;QAAMY;MAAM,IAAI,KAAKrB,OAAA,CAAQK,UAAU;MACtD,MAAMsB,OAAA,GAAUN,KAAA,CAAMM,OAAA,CAAQ;MAC9B,KAAKb,WAAA,CAAYT,UAAU;MAC3B,KAAKK,QAAA,CAASL,UAAA,EAAYG,KAAA,EAAOC,IAAA,EAAMkB,OAAO;IAChD;EACF;EAEAC,QAAA,EAAU;IACR,WAAWvB,UAAA,IAAcC,MAAA,CAAOC,IAAA,CAAK,KAAKP,OAAO,GAAG;MAClD,KAAKc,WAAA,CAAYT,UAAU;IAC7B;IACA,KAAKJ,SAAA,GAAY,mBAAIC,GAAA,CAAI;EAC3B;EAEQQ,SACNL,UAAA,EACAG,KAAA,EACAC,IAAA,EACAkB,OAAA,EACA;IACA,IAAI,KAAK3B,OAAA,CAAQK,UAAU,MAAM,QAAW;MAC1C,MAAM,IAAIoB,KAAA,CACR,4CAA4CpB,UAAA,0BAC9C;IACF;IACA,MAAMgB,KAAA,GAAQ,KAAKvB,WAAA,CAAYU,KAAA,EAAOC,IAAA,EAAMkB,OAAO;IACnD,MAAME,WAAA,GAAcR,KAAA,CAAMS,QAAA,CAAS,MAAM,KAAKC,eAAA,CAAgB,CAAC;IAC/D,KAAK/B,OAAA,CAAQK,UAAU,IAAI;MACzBG,KAAA;MACAC,IAAA;MACAY,KAAA;MACAQ;IACF;EACF;EAEQf,YAAYT,UAAA,EAAwB;IAC1C,MAAM2B,IAAA,GAAO,KAAKhC,OAAA,CAAQK,UAAU;IACpC,IAAI2B,IAAA,KAAS,QAAW;MACtB,MAAM,IAAIP,KAAA,CAAM,kCAAkCpB,UAAA,GAAa;IACjE;IACA2B,IAAA,CAAKH,WAAA,CAAY;IACjB,OAAO,KAAK7B,OAAA,CAAQK,UAAU;EAChC;EAEQ0B,gBAAA,EAAwB;IAC9B,WAAWf,QAAA,IAAY,KAAKf,SAAA,EAAW;MACrCe,QAAA,CAAS;IACX;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}