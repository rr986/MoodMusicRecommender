{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { convexToJson } from \"./value.js\";\nclass BaseValidator {\n  constructor(_ref) {\n    let {\n      isOptional\n    } = _ref;\n    /**\n     * Only for TypeScript, the TS type of the JS values validated\n     * by this validator.\n     */\n    __publicField(this, \"type\");\n    /**\n     * Only for TypeScript, if this an Object validator, then\n     * this is the TS type of its property names.\n     */\n    __publicField(this, \"fieldPaths\");\n    /**\n     * Whether this is an optional Object property value validator.\n     */\n    __publicField(this, \"isOptional\");\n    /**\n     * Always `\"true\"`.\n     */\n    __publicField(this, \"isConvexValidator\");\n    this.isOptional = isOptional;\n    this.isConvexValidator = true;\n  }\n  /** @deprecated - use isOptional instead */\n  get optional() {\n    return this.isOptional === \"optional\" ? true : false;\n  }\n}\nexport class VId extends BaseValidator {\n  /**\n   * Usually you'd use `v.id(tableName)` instead.\n   */\n  constructor(_ref2) {\n    let {\n      isOptional,\n      tableName\n    } = _ref2;\n    super({\n      isOptional\n    });\n    /**\n     * The name of the table that the validated IDs must belong to.\n     */\n    __publicField(this, \"tableName\");\n    /**\n     * The kind of validator, `\"id\"`.\n     */\n    __publicField(this, \"kind\", \"id\");\n    this.tableName = tableName;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: \"id\",\n      tableName: this.tableName\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VId({\n      isOptional: \"optional\",\n      tableName: this.tableName\n    });\n  }\n}\nexport class VFloat64 extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"float64\"`.\n     */\n    __publicField(this, \"kind\", \"float64\");\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: \"number\"\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VFloat64({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VInt64 extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"int64\"`.\n     */\n    __publicField(this, \"kind\", \"int64\");\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: \"bigint\"\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VInt64({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VBoolean extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"boolean\"`.\n     */\n    __publicField(this, \"kind\", \"boolean\");\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VBoolean({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VBytes extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"bytes\"`.\n     */\n    __publicField(this, \"kind\", \"bytes\");\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VBytes({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VString extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"string\"`.\n     */\n    __publicField(this, \"kind\", \"string\");\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VString({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VNull extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"null\"`.\n     */\n    __publicField(this, \"kind\", \"null\");\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VNull({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VAny extends BaseValidator {\n  constructor() {\n    super(...arguments);\n    /**\n     * The kind of validator, `\"any\"`.\n     */\n    __publicField(this, \"kind\", \"any\");\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VAny({\n      isOptional: \"optional\"\n    });\n  }\n}\nexport class VObject extends BaseValidator {\n  /**\n   * Usually you'd use `v.object({ ... })` instead.\n   */\n  constructor(_ref3) {\n    let {\n      isOptional,\n      fields\n    } = _ref3;\n    super({\n      isOptional\n    });\n    /**\n     * An object with the validator for each property.\n     */\n    __publicField(this, \"fields\");\n    /**\n     * The kind of validator, `\"object\"`.\n     */\n    __publicField(this, \"kind\", \"object\");\n    this.fields = fields;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: globalThis.Object.fromEntries(globalThis.Object.entries(this.fields).map(_ref4 => {\n        let [k, v] = _ref4;\n        return [k, {\n          fieldType: v.json,\n          optional: v.isOptional === \"optional\" ? true : false\n        }];\n      }))\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VObject({\n      isOptional: \"optional\",\n      fields: this.fields\n    });\n  }\n}\nexport class VLiteral extends BaseValidator {\n  /**\n   * Usually you'd use `v.literal(value)` instead.\n   */\n  constructor(_ref5) {\n    let {\n      isOptional,\n      value\n    } = _ref5;\n    super({\n      isOptional\n    });\n    /**\n     * The value that the validated values must be equal to.\n     */\n    __publicField(this, \"value\");\n    /**\n     * The kind of validator, `\"literal\"`.\n     */\n    __publicField(this, \"kind\", \"literal\");\n    this.value = value;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: convexToJson(this.value)\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VLiteral({\n      isOptional: \"optional\",\n      value: this.value\n    });\n  }\n}\nexport class VArray extends BaseValidator {\n  /**\n   * Usually you'd use `v.array(element)` instead.\n   */\n  constructor(_ref6) {\n    let {\n      isOptional,\n      element\n    } = _ref6;\n    super({\n      isOptional\n    });\n    /**\n     * The validator for the elements of the array.\n     */\n    __publicField(this, \"element\");\n    /**\n     * The kind of validator, `\"array\"`.\n     */\n    __publicField(this, \"kind\", \"array\");\n    this.element = element;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: this.element.json\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VArray({\n      isOptional: \"optional\",\n      element: this.element\n    });\n  }\n}\nexport class VRecord extends BaseValidator {\n  constructor(_ref7) {\n    let {\n      isOptional,\n      key,\n      value\n    } = _ref7;\n    super({\n      isOptional\n    });\n    __publicField(this, \"key\");\n    __publicField(this, \"value\");\n    __publicField(this, \"kind\", \"record\");\n    this.key = key;\n    this.value = value;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      keys: this.key.json,\n      values: {\n        fieldType: this.value.json,\n        optional: false\n      }\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VRecord({\n      isOptional: \"optional\",\n      key: this.key,\n      value: this.value\n    });\n  }\n}\nexport class VUnion extends BaseValidator {\n  /**\n   * Usually you'd use `v.union(...members)` instead.\n   */\n  constructor(_ref8) {\n    let {\n      isOptional,\n      members\n    } = _ref8;\n    super({\n      isOptional\n    });\n    /**\n     * The array of validators, one of which must match the value.\n     */\n    __publicField(this, \"members\");\n    /**\n     * The kind of validator, `\"union\"`.\n     */\n    __publicField(this, \"kind\", \"union\");\n    this.members = members;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: this.members.map(v => v.json)\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VUnion({\n      isOptional: \"optional\",\n      members: this.members\n    });\n  }\n}","map":{"version":3,"names":["convexToJson","BaseValidator","constructor","_ref","isOptional","__publicField","isConvexValidator","optional","VId","_ref2","tableName","json","type","asOptional","VFloat64","arguments","VInt64","VBoolean","kind","VBytes","VString","VNull","VAny","VObject","_ref3","fields","value","globalThis","Object","fromEntries","entries","map","_ref4","k","v","fieldType","VLiteral","_ref5","VArray","_ref6","element","VRecord","_ref7","key","keys","values","VUnion","_ref8","members"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/values/validators.ts"],"sourcesContent":["import { GenericId } from \"./index.js\";\nimport { GenericValidator } from \"./validator.js\";\nimport { JSONValue, convexToJson } from \"./value.js\";\n\ntype TableNameFromType<T> =\n  T extends GenericId<infer TableName> ? TableName : string;\n\n/**\n * Avoid using `instanceof BaseValidator`; this is inheritence for code reuse\n * not type heirarchy.\n */\nabstract class BaseValidator<\n  Type,\n  IsOptional extends OptionalProperty = \"required\",\n  FieldPaths extends string = never,\n> {\n  /**\n   * Only for TypeScript, the TS type of the JS values validated\n   * by this validator.\n   */\n  readonly type!: Type;\n  /**\n   * Only for TypeScript, if this an Object validator, then\n   * this is the TS type of its property names.\n   */\n  readonly fieldPaths!: FieldPaths;\n\n  /**\n   * Whether this is an optional Object property value validator.\n   */\n  readonly isOptional: IsOptional;\n\n  /**\n   * Always `\"true\"`.\n   */\n  readonly isConvexValidator: true;\n\n  constructor({ isOptional }: { isOptional: IsOptional }) {\n    this.isOptional = isOptional;\n    this.isConvexValidator = true;\n  }\n  /** @deprecated - use isOptional instead */\n  get optional(): boolean {\n    return this.isOptional === \"optional\" ? true : false;\n  }\n  /** @internal */\n  abstract get json(): ValidatorJSON;\n  /** @internal */\n  abstract asOptional(): Validator<Type | undefined, \"optional\", FieldPaths>;\n}\n\n/**\n * The type of the `v.id(tableName)` validator.\n */\nexport class VId<\n  Type,\n  IsOptional extends OptionalProperty = \"required\",\n> extends BaseValidator<Type, IsOptional> {\n  /**\n   * The name of the table that the validated IDs must belong to.\n   */\n  readonly tableName: TableNameFromType<Type>;\n\n  /**\n   * The kind of validator, `\"id\"`.\n   */\n  readonly kind = \"id\" as const;\n\n  /**\n   * Usually you'd use `v.id(tableName)` instead.\n   */\n  constructor({\n    isOptional,\n    tableName,\n  }: {\n    isOptional: IsOptional;\n    tableName: TableNameFromType<Type>;\n  }) {\n    super({ isOptional });\n    this.tableName = tableName;\n  }\n  /** @internal */\n  get json(): ValidatorJSON {\n    return { type: \"id\", tableName: this.tableName };\n  }\n  /** @internal */\n  asOptional() {\n    return new VId<Type | undefined, \"optional\">({\n      isOptional: \"optional\",\n      tableName: this.tableName,\n    });\n  }\n}\n\n/**\n * The type of the `v.float64()` validator.\n */\nexport class VFloat64<\n  Type = number,\n  IsOptional extends OptionalProperty = \"required\",\n> extends BaseValidator<Type, IsOptional> {\n  /**\n   * The kind of validator, `\"float64\"`.\n   */\n  readonly kind = \"float64\" as const;\n\n  /** @internal */\n  get json(): ValidatorJSON {\n    // Server expects the old name `number` string instead of `float64`.\n    return { type: \"number\" };\n  }\n  /** @internal */\n  asOptional() {\n    return new VFloat64<Type | undefined, \"optional\">({\n      isOptional: \"optional\",\n    });\n  }\n}\n\n/**\n * The type of the `v.int64()` validator.\n */\nexport class VInt64<\n  Type = bigint,\n  IsOptional extends OptionalProperty = \"required\",\n> extends BaseValidator<Type, IsOptional> {\n  /**\n   * The kind of validator, `\"int64\"`.\n   */\n  readonly kind = \"int64\" as const;\n\n  /** @internal */\n  get json(): ValidatorJSON {\n    // Server expects the old name `bigint`.\n    return { type: \"bigint\" };\n  }\n  /** @internal */\n  asOptional() {\n    return new VInt64<Type | undefined, \"optional\">({ isOptional: \"optional\" });\n  }\n}\n\n/**\n * The type of the `v.boolean()` validator.\n */\nexport class VBoolean<\n  Type = boolean,\n  IsOptional extends OptionalProperty = \"required\",\n> extends BaseValidator<Type, IsOptional> {\n  /**\n   * The kind of validator, `\"boolean\"`.\n   */\n  readonly kind = \"boolean\" as const;\n\n  /** @internal */\n  get json(): ValidatorJSON {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new VBoolean<Type | undefined, \"optional\">({\n      isOptional: \"optional\",\n    });\n  }\n}\n\n/**\n * The type of the `v.bytes()` validator.\n */\nexport class VBytes<\n  Type = ArrayBuffer,\n  IsOptional extends OptionalProperty = \"required\",\n> extends BaseValidator<Type, IsOptional> {\n  /**\n   * The kind of validator, `\"bytes\"`.\n   */\n  readonly kind = \"bytes\" as const;\n\n  /** @internal */\n  get json(): ValidatorJSON {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new VBytes<Type | undefined, \"optional\">({ isOptional: \"optional\" });\n  }\n}\n\n/**\n * The type of the `v.string()` validator.\n */\nexport class VString<\n  Type = string,\n  IsOptional extends OptionalProperty = \"required\",\n> extends BaseValidator<Type, IsOptional> {\n  /**\n   * The kind of validator, `\"string\"`.\n   */\n  readonly kind = \"string\" as const;\n\n  /** @internal */\n  get json(): ValidatorJSON {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new VString<Type | undefined, \"optional\">({\n      isOptional: \"optional\",\n    });\n  }\n}\n\n/**\n * The type of the `v.null()` validator.\n */\nexport class VNull<\n  Type = null,\n  IsOptional extends OptionalProperty = \"required\",\n> extends BaseValidator<Type, IsOptional> {\n  /**\n   * The kind of validator, `\"null\"`.\n   */\n  readonly kind = \"null\" as const;\n\n  /** @internal */\n  get json(): ValidatorJSON {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new VNull<Type | undefined, \"optional\">({ isOptional: \"optional\" });\n  }\n}\n\n/**\n * The type of the `v.any()` validator.\n */\nexport class VAny<\n  Type = any,\n  IsOptional extends OptionalProperty = \"required\",\n  FieldPaths extends string = string,\n> extends BaseValidator<Type, IsOptional, FieldPaths> {\n  /**\n   * The kind of validator, `\"any\"`.\n   */\n  readonly kind = \"any\" as const;\n\n  /** @internal */\n  get json(): ValidatorJSON {\n    return {\n      type: this.kind,\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VAny<Type | undefined, \"optional\", FieldPaths>({\n      isOptional: \"optional\",\n    });\n  }\n}\n\n/**\n * The type of the `v.object()` validator.\n */\nexport class VObject<\n  Type,\n  Fields extends Record<string, GenericValidator>,\n  IsOptional extends OptionalProperty = \"required\",\n  FieldPaths extends string = {\n    [Property in keyof Fields]:\n      | JoinFieldPaths<Property & string, Fields[Property][\"fieldPaths\"]>\n      | Property;\n  }[keyof Fields] &\n    string,\n> extends BaseValidator<Type, IsOptional, FieldPaths> {\n  /**\n   * An object with the validator for each property.\n   */\n  readonly fields: Fields;\n\n  /**\n   * The kind of validator, `\"object\"`.\n   */\n  readonly kind = \"object\" as const;\n\n  /**\n   * Usually you'd use `v.object({ ... })` instead.\n   */\n  constructor({\n    isOptional,\n    fields,\n  }: {\n    isOptional: IsOptional;\n    fields: Fields;\n  }) {\n    super({ isOptional });\n    this.fields = fields;\n  }\n  /** @internal */\n  get json(): ValidatorJSON {\n    return {\n      type: this.kind,\n      value: globalThis.Object.fromEntries(\n        globalThis.Object.entries(this.fields).map(([k, v]) => [\n          k,\n          {\n            fieldType: v.json,\n            optional: v.isOptional === \"optional\" ? true : false,\n          },\n        ]),\n      ),\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VObject<Type | undefined, Fields, \"optional\", FieldPaths>({\n      isOptional: \"optional\",\n      fields: this.fields,\n    });\n  }\n}\n\n/**\n * The type of the `v.literal()` validator.\n */\nexport class VLiteral<\n  Type,\n  IsOptional extends OptionalProperty = \"required\",\n> extends BaseValidator<Type, IsOptional> {\n  /**\n   * The value that the validated values must be equal to.\n   */\n  readonly value: Type;\n\n  /**\n   * The kind of validator, `\"literal\"`.\n   */\n  readonly kind = \"literal\" as const;\n\n  /**\n   * Usually you'd use `v.literal(value)` instead.\n   */\n  constructor({ isOptional, value }: { isOptional: IsOptional; value: Type }) {\n    super({ isOptional });\n    this.value = value;\n  }\n  /** @internal */\n  get json(): ValidatorJSON {\n    return {\n      type: this.kind,\n      value: convexToJson(this.value as string | boolean | number | bigint),\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VLiteral<Type | undefined, \"optional\">({\n      isOptional: \"optional\",\n      value: this.value,\n    });\n  }\n}\n\n/**\n * The type of the `v.array()` validator.\n */\nexport class VArray<\n  Type,\n  Element extends Validator<any, \"required\", any>,\n  IsOptional extends OptionalProperty = \"required\",\n> extends BaseValidator<Type, IsOptional> {\n  /**\n   * The validator for the elements of the array.\n   */\n  readonly element: Element;\n\n  /**\n   * The kind of validator, `\"array\"`.\n   */\n  readonly kind = \"array\" as const;\n\n  /**\n   * Usually you'd use `v.array(element)` instead.\n   */\n  constructor({\n    isOptional,\n    element,\n  }: {\n    isOptional: IsOptional;\n    element: Element;\n  }) {\n    super({ isOptional });\n    this.element = element;\n  }\n  /** @internal */\n  get json(): ValidatorJSON {\n    return {\n      type: this.kind,\n      value: this.element.json,\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VArray<Type | undefined, Element, \"optional\">({\n      isOptional: \"optional\",\n      element: this.element,\n    });\n  }\n}\n\n/**\n * Validator for an object that produces indexed types.\n *\n * If the value validator is not optional, it produces a `Record` type, which is an alias\n * for `{[key: K]: V}`.\n *\n * If the value validator is optional, it produces a mapped object type,\n * with optional keys: `{[key in K]?: V}`.\n *\n * This is used within the validator builder, {@link v}.\n */\nexport class VRecord<\n  Type,\n  Key extends Validator<string, \"required\", any>,\n  Value extends Validator<any, \"required\", any>,\n  IsOptional extends OptionalProperty = \"required\",\n  FieldPaths extends string = string,\n> extends BaseValidator<Type, IsOptional, FieldPaths> {\n  readonly key: Key;\n  readonly value: Value;\n  readonly kind = \"record\" as const;\n  constructor({\n    isOptional,\n    key,\n    value,\n  }: {\n    isOptional: IsOptional;\n    key: Key;\n    value: Value;\n  }) {\n    super({ isOptional });\n    this.key = key;\n    this.value = value;\n  }\n  /** @internal */\n  get json(): ValidatorJSON {\n    return {\n      type: this.kind,\n      keys: this.key.json,\n      values: {\n        fieldType: this.value.json,\n        optional: false,\n      },\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VRecord<Type | undefined, Key, Value, \"optional\", FieldPaths>({\n      isOptional: \"optional\",\n      key: this.key,\n      value: this.value,\n    });\n  }\n}\n\n/**\n * The type of the `v.union()` validator.\n */\nexport class VUnion<\n  Type,\n  T extends Validator<any, \"required\", any>[],\n  IsOptional extends OptionalProperty = \"required\",\n  FieldPaths extends string = T[number][\"fieldPaths\"],\n> extends BaseValidator<Type, IsOptional, FieldPaths> {\n  /**\n   * The array of validators, one of which must match the value.\n   */\n  readonly members: T;\n\n  /**\n   * The kind of validator, `\"union\"`.\n   */\n  readonly kind = \"union\" as const;\n\n  /**\n   * Usually you'd use `v.union(...members)` instead.\n   */\n  constructor({ isOptional, members }: { isOptional: IsOptional; members: T }) {\n    super({ isOptional });\n    this.members = members;\n  }\n  /** @internal */\n  get json(): ValidatorJSON {\n    return {\n      type: this.kind,\n      value: this.members.map((v) => v.json),\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new VUnion<Type | undefined, T, \"optional\">({\n      isOptional: \"optional\",\n      members: this.members,\n    });\n  }\n}\n\n// prettier-ignore\nexport type VOptional<T extends Validator<any, OptionalProperty, any>> =\n  T extends VId<infer Type, OptionalProperty> ? VId<Type | undefined, \"optional\">\n  : T extends VString<infer Type, OptionalProperty>\n    ? VString<Type | undefined, \"optional\">\n  : T extends VFloat64<infer Type, OptionalProperty>\n    ? VFloat64<Type | undefined, \"optional\">\n  : T extends VInt64<infer Type, OptionalProperty>\n    ? VInt64<Type | undefined, \"optional\">\n  : T extends VBoolean<infer Type, OptionalProperty>\n    ? VBoolean<Type | undefined, \"optional\">\n  : T extends VNull<infer Type, OptionalProperty>\n    ? VNull<Type | undefined, \"optional\">\n  : T extends VAny<infer Type, OptionalProperty>\n    ? VAny<Type | undefined, \"optional\">\n  : T extends VLiteral<infer Type, OptionalProperty>\n    ? VLiteral<Type | undefined, \"optional\">\n  : T extends VBytes<infer Type, OptionalProperty>\n    ? VBytes<Type | undefined, \"optional\">\n  : T extends VObject< infer Type, infer Fields, OptionalProperty, infer FieldPaths>\n    ? VObject<Type | undefined, Fields, \"optional\", FieldPaths>\n  : T extends VArray<infer Type, infer Element, OptionalProperty>\n    ? VArray<Type | undefined, Element, \"optional\">\n  : T extends VRecord< infer Type, infer Key, infer Value, OptionalProperty, infer FieldPaths>\n    ? VRecord<Type | undefined, Key, Value, \"optional\", FieldPaths>\n  : T extends VUnion<infer Type, infer Members, OptionalProperty, infer FieldPaths>\n    ? VUnion<Type | undefined, Members, \"optional\", FieldPaths>\n  : never\n\n/**\n * Type representing whether a property in an object is optional or required.\n *\n * @public\n */\nexport type OptionalProperty = \"optional\" | \"required\";\n\n/**\n * A validator for a Convex value.\n *\n * This should be constructed using the validator builder, {@link v}.\n *\n * A validator encapsulates:\n * - The TypeScript type of this value.\n * - Whether this field should be optional if it's included in an object.\n * - The TypeScript type for the set of index field paths that can be used to\n * build indexes on this value.\n * - A JSON representation of the validator.\n *\n * Specific types of validators contain additional information: for example\n * an `ArrayValidator` contains an `element` property with the validator\n * used to validate each element of the list. Use the shared 'kind' property\n * to identity the type of validator.\n *\n * More validators can be added in future releases so an exhaustive\n * switch statement on validator `kind` should be expected to break\n * in future releases of Convex.\n *\n * @public\n */\nexport type Validator<\n  Type,\n  IsOptional extends OptionalProperty = \"required\",\n  FieldPaths extends string = never,\n> =\n  | VId<Type, IsOptional>\n  | VString<Type, IsOptional>\n  | VFloat64<Type, IsOptional>\n  | VInt64<Type, IsOptional>\n  | VBoolean<Type, IsOptional>\n  | VNull<Type, IsOptional>\n  | VAny<Type, IsOptional>\n  | VLiteral<Type, IsOptional>\n  | VBytes<Type, IsOptional>\n  | VObject<\n      Type,\n      Record<string, Validator<any, OptionalProperty, any>>,\n      IsOptional,\n      FieldPaths\n    >\n  | VArray<Type, Validator<any, \"required\", any>, IsOptional>\n  | VRecord<\n      Type,\n      Validator<string, \"required\", any>,\n      Validator<any, \"required\", any>,\n      IsOptional,\n      FieldPaths\n    >\n  | VUnion<Type, Validator<any, \"required\", any>[], IsOptional, FieldPaths>;\n\n/**\n * Join together two index field paths.\n *\n * This is used within the validator builder, {@link v}.\n * @public\n */\nexport type JoinFieldPaths<\n  Start extends string,\n  End extends string,\n> = `${Start}.${End}`;\n\nexport type ObjectFieldType = { fieldType: ValidatorJSON; optional: boolean };\n\nexport type ValidatorJSON =\n  | { type: \"null\" }\n  | { type: \"number\" }\n  | { type: \"bigint\" }\n  | { type: \"boolean\" }\n  | { type: \"string\" }\n  | { type: \"bytes\" }\n  | { type: \"any\" }\n  | { type: \"literal\"; value: JSONValue }\n  | { type: \"id\"; tableName: string }\n  | { type: \"array\"; value: ValidatorJSON }\n  | { type: \"record\"; keys: ValidatorJSON; values: ObjectFieldType }\n  | { type: \"object\"; value: Record<string, ObjectFieldType> }\n  | { type: \"union\"; value: ValidatorJSON[] };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}