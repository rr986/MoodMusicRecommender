{"ast":null,"code":"\"use strict\";\n\nimport { VAny, VArray, VBoolean, VBytes, VFloat64, VId, VInt64, VLiteral, VNull, VObject, VRecord, VString, VUnion } from \"./validators.js\";\nexport function isValidator(v2) {\n  return !!v2.isConvexValidator;\n}\nexport function asObjectValidator(obj) {\n  if (isValidator(obj)) {\n    return obj;\n  } else {\n    return v.object(obj);\n  }\n}\nexport const v = {\n  /**\n   * Validates that the value corresponds to an ID of a document in given table.\n   * @param tableName The name of the table.\n   */\n  id: tableName => {\n    return new VId({\n      isOptional: \"required\",\n      tableName\n    });\n  },\n  /**\n   * Validates that the value is of type Null.\n   */\n  null: () => {\n    return new VNull({\n      isOptional: \"required\"\n    });\n  },\n  /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   *\n   * Alias for `v.float64()`\n   */\n  number: () => {\n    return new VFloat64({\n      isOptional: \"required\"\n    });\n  },\n  /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   */\n  float64: () => {\n    return new VFloat64({\n      isOptional: \"required\"\n    });\n  },\n  /**\n   * @deprecated Use `v.int64()` instead\n   */\n  bigint: () => {\n    return new VInt64({\n      isOptional: \"required\"\n    });\n  },\n  /**\n   * Validates that the value is of Convex type Int64 (BigInt in JS).\n   */\n  int64: () => {\n    return new VInt64({\n      isOptional: \"required\"\n    });\n  },\n  /**\n   * Validates that the value is of type Boolean.\n   */\n  boolean: () => {\n    return new VBoolean({\n      isOptional: \"required\"\n    });\n  },\n  /**\n   * Validates that the value is of type String.\n   */\n  string: () => {\n    return new VString({\n      isOptional: \"required\"\n    });\n  },\n  /**\n   * Validates that the value is of Convex type Bytes (constructed in JS via `ArrayBuffer`).\n   */\n  bytes: () => {\n    return new VBytes({\n      isOptional: \"required\"\n    });\n  },\n  /**\n   * Validates that the value is equal to the given literal value.\n   * @param literal The literal value to compare against.\n   */\n  literal: literal => {\n    return new VLiteral({\n      isOptional: \"required\",\n      value: literal\n    });\n  },\n  /**\n   * Validates that the value is an Array of the given element type.\n   * @param element The validator for the elements of the array.\n   */\n  array: element => {\n    return new VArray({\n      isOptional: \"required\",\n      element\n    });\n  },\n  /**\n   * Validates that the value is an Object with the given properties.\n   * @param fields An object specifying the validator for each property.\n   */\n  object: fields => {\n    return new VObject({\n      isOptional: \"required\",\n      fields\n    });\n  },\n  /** @internal */\n  record: (keys, values) => {\n    return new VRecord({\n      isOptional: \"required\",\n      key: keys,\n      value: values\n    });\n  },\n  /**\n   * Validates that the value matches one of the given validators.\n   * @param members The validators to match against.\n   */\n  union: function () {\n    for (var _len = arguments.length, members = new Array(_len), _key = 0; _key < _len; _key++) {\n      members[_key] = arguments[_key];\n    }\n    return new VUnion({\n      isOptional: \"required\",\n      members\n    });\n  },\n  /**\n   * Does not validate the value.\n   */\n  any: () => {\n    return new VAny({\n      isOptional: \"required\"\n    });\n  },\n  /**\n   * Allows not specifying a value for a property in an Object.\n   * @param value The property value validator to make optional.\n   *\n   * ```typescript\n   * const objectWithOptionalFields = v.object({\n   *   requiredField: v.string(),\n   *   optionalField: v.optional(v.string()),\n   * });\n   * ```\n   */\n  optional: value => {\n    return value.asOptional();\n  }\n};","map":{"version":3,"names":["VAny","VArray","VBoolean","VBytes","VFloat64","VId","VInt64","VLiteral","VNull","VObject","VRecord","VString","VUnion","isValidator","v2","isConvexValidator","asObjectValidator","obj","v","object","id","tableName","isOptional","null","number","float64","bigint","int64","boolean","string","bytes","literal","value","array","element","fields","record","keys","values","key","union","_len","arguments","length","members","Array","_key","any","optional","asOptional"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/values/validator.ts"],"sourcesContent":["import { Expand } from \"../type_utils.js\";\nimport { GenericId } from \"./index.js\";\nimport {\n  OptionalProperty,\n  VAny,\n  VArray,\n  VBoolean,\n  VBytes,\n  VFloat64,\n  VId,\n  VInt64,\n  VLiteral,\n  VNull,\n  VObject,\n  VOptional,\n  VRecord,\n  VString,\n  VUnion,\n  Validator,\n} from \"./validators.js\";\n\n/**\n * The type that all validators must extend.\n *\n * @public\n */\nexport type GenericValidator = Validator<any, any, any>;\n\nexport function isValidator(v: any): v is GenericValidator {\n  return !!v.isConvexValidator;\n}\n\n/**\n * Coerce an object with validators as properties to a validator.\n * If a validator is passed, return it.\n *\n * @public\n */\nexport function asObjectValidator<\n  V extends Validator<any, any, any> | PropertyValidators,\n>(\n  obj: V,\n): V extends Validator<any, any, any>\n  ? V\n  : V extends PropertyValidators\n    ? Validator<ObjectType<V>>\n    : never {\n  if (isValidator(obj)) {\n    return obj as any;\n  } else {\n    return v.object(obj as PropertyValidators) as any;\n  }\n}\n\n/**\n * Coerce an object with validators as properties to a validator.\n * If a validator is passed, return it.\n *\n * @public\n */\nexport type AsObjectValidator<\n  V extends Validator<any, any, any> | PropertyValidators,\n> =\n  V extends Validator<any, any, any>\n    ? V\n    : V extends PropertyValidators\n      ? Validator<ObjectType<V>>\n      : never;\n\n/**\n * The validator builder.\n *\n * This builder allows you to build validators for Convex values.\n *\n * Validators can be used in [schema definitions](https://docs.convex.dev/database/schemas)\n * and as input validators for Convex functions.\n *\n * @public\n */\nexport const v = {\n  /**\n   * Validates that the value corresponds to an ID of a document in given table.\n   * @param tableName The name of the table.\n   */\n  id: <TableName extends string>(tableName: TableName) => {\n    return new VId<GenericId<TableName>>({\n      isOptional: \"required\",\n      tableName,\n    });\n  },\n\n  /**\n   * Validates that the value is of type Null.\n   */\n  null: () => {\n    return new VNull({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   *\n   * Alias for `v.float64()`\n   */\n  number: () => {\n    return new VFloat64({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   */\n  float64: () => {\n    return new VFloat64({ isOptional: \"required\" });\n  },\n\n  /**\n   * @deprecated Use `v.int64()` instead\n   */\n  bigint: () => {\n    return new VInt64({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is of Convex type Int64 (BigInt in JS).\n   */\n  int64: () => {\n    return new VInt64({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is of type Boolean.\n   */\n  boolean: () => {\n    return new VBoolean({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is of type String.\n   */\n  string: () => {\n    return new VString({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is of Convex type Bytes (constructed in JS via `ArrayBuffer`).\n   */\n  bytes: () => {\n    return new VBytes({ isOptional: \"required\" });\n  },\n\n  /**\n   * Validates that the value is equal to the given literal value.\n   * @param literal The literal value to compare against.\n   */\n  literal: <T extends string | number | bigint | boolean>(literal: T) => {\n    return new VLiteral<T>({ isOptional: \"required\", value: literal });\n  },\n\n  /**\n   * Validates that the value is an Array of the given element type.\n   * @param element The validator for the elements of the array.\n   */\n  array: <T extends Validator<any, \"required\", any>>(element: T) => {\n    return new VArray<T[\"type\"][], T>({ isOptional: \"required\", element });\n  },\n\n  /**\n   * Validates that the value is an Object with the given properties.\n   * @param fields An object specifying the validator for each property.\n   */\n  object: <T extends PropertyValidators>(fields: T) => {\n    return new VObject<ObjectType<T>, T>({ isOptional: \"required\", fields });\n  },\n\n  /** @internal */\n  record: <\n    Key extends Validator<any, \"required\", any>,\n    Value extends Validator<any, \"required\", any>,\n  >(\n    keys: Key,\n    values: Value,\n  ) => {\n    // TODO enforce that Infer<key> extends string\n    return new VRecord<\n      Value[\"isOptional\"] extends true\n        ? { [key in Infer<Key>]?: Value[\"type\"] }\n        : Record<Infer<Key>, Value[\"type\"]>,\n      Key,\n      Value\n    >({\n      isOptional: \"required\",\n      key: keys,\n      value: values,\n    });\n  },\n\n  /**\n   * Validates that the value matches one of the given validators.\n   * @param members The validators to match against.\n   */\n  union: <T extends Validator<any, \"required\", any>[]>(...members: T) => {\n    return new VUnion<T[number][\"type\"], T>({\n      isOptional: \"required\",\n      members,\n    });\n  },\n\n  /**\n   * Does not validate the value.\n   */\n  any: () => {\n    return new VAny({ isOptional: \"required\" });\n  },\n\n  /**\n   * Allows not specifying a value for a property in an Object.\n   * @param value The property value validator to make optional.\n   *\n   * ```typescript\n   * const objectWithOptionalFields = v.object({\n   *   requiredField: v.string(),\n   *   optionalField: v.optional(v.string()),\n   * });\n   * ```\n   */\n  optional: <T extends GenericValidator>(value: T) => {\n    return value.asOptional() as VOptional<T>;\n  },\n};\n\n/**\n * Validators for each property of an object.\n *\n * This is represented as an object mapping the property name to its\n * {@link Validator}.\n *\n * @public\n */\nexport type PropertyValidators = Record<\n  string,\n  Validator<any, OptionalProperty, any>\n>;\n\n/**\n * Compute the type of an object from {@link PropertyValidators}.\n *\n * @public\n */\nexport type ObjectType<Fields extends PropertyValidators> = Expand<\n  // Map each key to the corresponding property validator's type making\n  // the optional ones optional.\n  {\n    // This `Exclude<..., undefined>` does nothing unless\n    // the tsconfig.json option `\"exactOptionalPropertyTypes\": true,`\n    // is used. When it is it results in a more accurate type.\n    // When it is not the `Exclude` removes `undefined` but it is\n    // added again by the optional property.\n    [Property in OptionalKeys<Fields>]?: Exclude<\n      Infer<Fields[Property]>,\n      undefined\n    >;\n  } & {\n    [Property in RequiredKeys<Fields>]: Infer<Fields[Property]>;\n  }\n>;\n\ntype OptionalKeys<PropertyValidators extends Record<string, GenericValidator>> =\n  {\n    [Property in keyof PropertyValidators]: PropertyValidators[Property][\"isOptional\"] extends \"optional\"\n      ? Property\n      : never;\n  }[keyof PropertyValidators];\n\ntype RequiredKeys<PropertyValidators extends Record<string, GenericValidator>> =\n  Exclude<keyof PropertyValidators, OptionalKeys<PropertyValidators>>;\n\n/**\n * Extract a TypeScript type from a validator.\n *\n * Example usage:\n * ```ts\n * const objectSchema = v.object({\n *   property: v.string(),\n * });\n * type MyObject = Infer<typeof objectSchema>; // { property: string }\n * ```\n * @typeParam V - The type of a {@link Validator} constructed with {@link v}.\n *\n * @public\n */\nexport type Infer<T extends Validator<any, OptionalProperty, any>> = T[\"type\"];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}