{"ast":null,"code":"\"use strict\";\n\nimport { useMemo, useState } from \"react\";\nimport { convexToJson } from \"../values/index.js\";\nimport { useQueries } from \"./use_queries.js\";\nimport { getFunctionName } from \"../server/api.js\";\nconst splitQuery = (key, splitCursor, continueCursor) => prevState => {\n  const queries = {\n    ...prevState.queries\n  };\n  const splitKey1 = prevState.nextPageKey;\n  const splitKey2 = prevState.nextPageKey + 1;\n  const nextPageKey = prevState.nextPageKey + 2;\n  queries[splitKey1] = {\n    query: prevState.query,\n    args: {\n      ...prevState.args,\n      paginationOpts: {\n        ...prevState.queries[key].args.paginationOpts,\n        endCursor: splitCursor\n      }\n    }\n  };\n  queries[splitKey2] = {\n    query: prevState.query,\n    args: {\n      ...prevState.args,\n      paginationOpts: {\n        ...prevState.queries[key].args.paginationOpts,\n        cursor: splitCursor,\n        endCursor: continueCursor\n      }\n    }\n  };\n  const ongoingSplits = {\n    ...prevState.ongoingSplits\n  };\n  ongoingSplits[key] = [splitKey1, splitKey2];\n  return {\n    ...prevState,\n    nextPageKey,\n    queries,\n    ongoingSplits\n  };\n};\nconst completeSplitQuery = key => prevState => {\n  const completedSplit = prevState.ongoingSplits[key];\n  if (completedSplit === void 0) {\n    return prevState;\n  }\n  const queries = {\n    ...prevState.queries\n  };\n  delete queries[key];\n  const ongoingSplits = {\n    ...prevState.ongoingSplits\n  };\n  delete ongoingSplits[key];\n  let pageKeys = prevState.pageKeys.slice();\n  const pageIndex = prevState.pageKeys.findIndex(v => v === key);\n  if (pageIndex >= 0) {\n    pageKeys = [...prevState.pageKeys.slice(0, pageIndex), ...completedSplit, ...prevState.pageKeys.slice(pageIndex + 1)];\n  }\n  return {\n    ...prevState,\n    queries,\n    pageKeys,\n    ongoingSplits\n  };\n};\nexport function usePaginatedQuery(query, args, options) {\n  if (typeof options?.initialNumItems !== \"number\" || options.initialNumItems < 0) {\n    throw new Error(`\\`options.initialNumItems\\` must be a positive number. Received \\`${options?.initialNumItems}\\`.`);\n  }\n  const skip = args === \"skip\";\n  const argsObject = skip ? {} : args;\n  const queryName = getFunctionName(query);\n  const createInitialState = useMemo(() => {\n    return () => {\n      const id = nextPaginationId();\n      return {\n        query,\n        args: argsObject,\n        id,\n        nextPageKey: 1,\n        pageKeys: skip ? [] : [0],\n        queries: skip ? {} : {\n          0: {\n            query,\n            args: {\n              ...argsObject,\n              paginationOpts: {\n                numItems: options.initialNumItems,\n                cursor: null,\n                id\n              }\n            }\n          }\n        },\n        ongoingSplits: {},\n        skip\n      };\n    };\n  }, [\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  JSON.stringify(convexToJson(argsObject)), queryName, options.initialNumItems, skip]);\n  const [state, setState] = useState(createInitialState);\n  let currState = state;\n  if (getFunctionName(query) !== getFunctionName(state.query) || JSON.stringify(convexToJson(argsObject)) !== JSON.stringify(convexToJson(state.args)) || skip !== state.skip) {\n    currState = createInitialState();\n    setState(currState);\n  }\n  const resultsObject = useQueries(currState.queries);\n  const [results, maybeLastResult] = useMemo(() => {\n    let currResult = void 0;\n    const allItems = [];\n    for (const pageKey of currState.pageKeys) {\n      currResult = resultsObject[pageKey];\n      if (currResult === void 0) {\n        break;\n      }\n      if (currResult instanceof Error) {\n        if (currResult.message.includes(\"InvalidCursor\")) {\n          console.warn(\"usePaginatedQuery hit error, resetting pagination state: \" + currResult.message);\n          setState(createInitialState);\n          return [[], void 0];\n        } else {\n          throw currResult;\n        }\n      }\n      const ongoingSplit = currState.ongoingSplits[pageKey];\n      if (ongoingSplit !== void 0) {\n        if (resultsObject[ongoingSplit[0]] !== void 0 && resultsObject[ongoingSplit[1]] !== void 0) {\n          setState(completeSplitQuery(pageKey));\n        }\n      } else if (currResult.splitCursor && (currResult.pageStatus === \"SplitRecommended\" || currResult.pageStatus === \"SplitRequired\" || currResult.page.length > options.initialNumItems * 2)) {\n        setState(splitQuery(pageKey, currResult.splitCursor, currResult.continueCursor));\n      }\n      if (currResult.pageStatus === \"SplitRequired\") {\n        return [allItems, void 0];\n      }\n      allItems.push(...currResult.page);\n    }\n    return [allItems, currResult];\n  }, [resultsObject, currState.pageKeys, currState.ongoingSplits, options.initialNumItems, createInitialState]);\n  const statusObject = useMemo(() => {\n    if (maybeLastResult === void 0) {\n      if (currState.nextPageKey === 1) {\n        return {\n          status: \"LoadingFirstPage\",\n          isLoading: true,\n          loadMore: _numItems => {}\n        };\n      } else {\n        return {\n          status: \"LoadingMore\",\n          isLoading: true,\n          loadMore: _numItems => {}\n        };\n      }\n    }\n    if (maybeLastResult.isDone) {\n      return {\n        status: \"Exhausted\",\n        isLoading: false,\n        loadMore: _numItems => {}\n      };\n    }\n    const continueCursor = maybeLastResult.continueCursor;\n    let alreadyLoadingMore = false;\n    return {\n      status: \"CanLoadMore\",\n      isLoading: false,\n      loadMore: numItems => {\n        if (!alreadyLoadingMore) {\n          alreadyLoadingMore = true;\n          setState(prevState => {\n            const pageKeys = [...prevState.pageKeys, prevState.nextPageKey];\n            const queries = {\n              ...prevState.queries\n            };\n            queries[prevState.nextPageKey] = {\n              query: prevState.query,\n              args: {\n                ...prevState.args,\n                paginationOpts: {\n                  numItems,\n                  cursor: continueCursor,\n                  id: prevState.id\n                }\n              }\n            };\n            return {\n              ...prevState,\n              nextPageKey: prevState.nextPageKey + 1,\n              pageKeys,\n              queries\n            };\n          });\n        }\n      }\n    };\n  }, [maybeLastResult, currState.nextPageKey]);\n  return {\n    results,\n    ...statusObject\n  };\n}\nlet paginationId = 0;\nfunction nextPaginationId() {\n  paginationId++;\n  return paginationId;\n}\nexport function resetPaginationId() {\n  paginationId = 0;\n}\nexport function optimisticallyUpdateValueInPaginatedQuery(localStore, query, args, updateValue) {\n  const expectedArgs = JSON.stringify(convexToJson(args));\n  for (const queryResult of localStore.getAllQueries(query)) {\n    if (queryResult.value !== void 0) {\n      const {\n        paginationOpts: _,\n        ...innerArgs\n      } = queryResult.args;\n      if (JSON.stringify(convexToJson(innerArgs)) === expectedArgs) {\n        const value = queryResult.value;\n        if (typeof value === \"object\" && value !== null && Array.isArray(value.page)) {\n          localStore.setQuery(query, queryResult.args, {\n            ...value,\n            page: value.page.map(updateValue)\n          });\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["useMemo","useState","convexToJson","useQueries","getFunctionName","splitQuery","key","splitCursor","continueCursor","prevState","queries","splitKey1","nextPageKey","splitKey2","query","args","paginationOpts","endCursor","cursor","ongoingSplits","completeSplitQuery","completedSplit","pageKeys","slice","pageIndex","findIndex","v","usePaginatedQuery","options","initialNumItems","Error","skip","argsObject","queryName","createInitialState","id","nextPaginationId","numItems","JSON","stringify","state","setState","currState","resultsObject","results","maybeLastResult","currResult","allItems","pageKey","message","includes","console","warn","ongoingSplit","pageStatus","page","length","push","statusObject","status","isLoading","loadMore","_numItems","isDone","alreadyLoadingMore","paginationId","resetPaginationId","optimisticallyUpdateValueInPaginatedQuery","localStore","updateValue","expectedArgs","queryResult","getAllQueries","value","_","innerArgs","Array","isArray","setQuery","map"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/react/use_paginated_query.ts"],"sourcesContent":["import { useMemo, useState } from \"react\";\n\nimport { OptimisticLocalStore } from \"../browser/index.js\";\nimport {\n  FunctionReturnType,\n  PaginationOptions,\n  paginationOptsValidator,\n  PaginationResult,\n} from \"../server/index.js\";\nimport { convexToJson, Infer, Value } from \"../values/index.js\";\nimport { useQueries } from \"./use_queries.js\";\nimport {\n  FunctionArgs,\n  FunctionReference,\n  getFunctionName,\n} from \"../server/api.js\";\nimport { BetterOmit, Expand } from \"../type_utils.js\";\n\n/**\n * A {@link server.FunctionReference} that is usable with {@link usePaginatedQuery}.\n *\n * This function reference must:\n * - Refer to a public query\n * - Have an argument named \"paginationOpts\" of type {@link server.PaginationOptions}\n * - Have a return type of {@link server.PaginationResult}.\n *\n * @public\n */\nexport type PaginatedQueryReference = FunctionReference<\n  \"query\",\n  \"public\",\n  { paginationOpts: PaginationOptions },\n  PaginationResult<any>\n>;\n\n// Incrementing integer for each page queried in the usePaginatedQuery hook.\ntype QueryPageKey = number;\n\ntype UsePaginatedQueryState = {\n  query: FunctionReference<\"query\">;\n  args: Record<string, Value>;\n  id: number;\n  nextPageKey: QueryPageKey;\n  pageKeys: QueryPageKey[];\n  queries: Record<\n    QueryPageKey,\n    {\n      query: FunctionReference<\"query\">;\n      // Use the validator type as a test that it matches the args\n      // we generate.\n      args: { paginationOpts: Infer<typeof paginationOptsValidator> };\n    }\n  >;\n  ongoingSplits: Record<QueryPageKey, [QueryPageKey, QueryPageKey]>;\n  skip: boolean;\n};\n\nconst splitQuery =\n  (key: QueryPageKey, splitCursor: string, continueCursor: string) =>\n  (prevState: UsePaginatedQueryState) => {\n    const queries = { ...prevState.queries };\n    const splitKey1 = prevState.nextPageKey;\n    const splitKey2 = prevState.nextPageKey + 1;\n    const nextPageKey = prevState.nextPageKey + 2;\n    queries[splitKey1] = {\n      query: prevState.query,\n      args: {\n        ...prevState.args,\n        paginationOpts: {\n          ...prevState.queries[key].args.paginationOpts,\n          endCursor: splitCursor,\n        },\n      },\n    };\n    queries[splitKey2] = {\n      query: prevState.query,\n      args: {\n        ...prevState.args,\n        paginationOpts: {\n          ...prevState.queries[key].args.paginationOpts,\n          cursor: splitCursor,\n          endCursor: continueCursor,\n        },\n      },\n    };\n    const ongoingSplits = { ...prevState.ongoingSplits };\n    ongoingSplits[key] = [splitKey1, splitKey2];\n    return {\n      ...prevState,\n      nextPageKey,\n      queries,\n      ongoingSplits,\n    };\n  };\n\nconst completeSplitQuery =\n  (key: QueryPageKey) => (prevState: UsePaginatedQueryState) => {\n    const completedSplit = prevState.ongoingSplits[key];\n    if (completedSplit === undefined) {\n      return prevState;\n    }\n    const queries = { ...prevState.queries };\n    delete queries[key];\n    const ongoingSplits = { ...prevState.ongoingSplits };\n    delete ongoingSplits[key];\n    let pageKeys = prevState.pageKeys.slice();\n    const pageIndex = prevState.pageKeys.findIndex((v) => v === key);\n    if (pageIndex >= 0) {\n      pageKeys = [\n        ...prevState.pageKeys.slice(0, pageIndex),\n        ...completedSplit,\n        ...prevState.pageKeys.slice(pageIndex + 1),\n      ];\n    }\n    return {\n      ...prevState,\n      queries,\n      pageKeys,\n      ongoingSplits,\n    };\n  };\n\n/**\n * Load data reactively from a paginated query to a create a growing list.\n *\n * This can be used to power \"infinite scroll\" UIs.\n *\n * This hook must be used with public query references that match\n * {@link PaginatedQueryReference}.\n *\n * `usePaginatedQuery` concatenates all the pages of results into a single list\n * and manages the continuation cursors when requesting more items.\n *\n * Example usage:\n * ```typescript\n * const { results, status, isLoading, loadMore } = usePaginatedQuery(\n *   api.messages.list,\n *   { channel: \"#general\" },\n *   { initialNumItems: 5 }\n * );\n * ```\n *\n * If the query reference or arguments change, the pagination state will be reset\n * to the first page. Similarly, if any of the pages result in an InvalidCursor\n * error or an error associated with too much data, the pagination state will also\n * reset to the first page.\n *\n * To learn more about pagination, see [Paginated Queries](https://docs.convex.dev/database/pagination).\n *\n * @param query - A FunctionReference to the public query function to run.\n * @param args - The arguments object for the query function, excluding\n * the `paginationOpts` property. That property is injected by this hook.\n * @param options - An object specifying the `initialNumItems` to be loaded in\n * the first page.\n * @returns A {@link UsePaginatedQueryResult} that includes the currently loaded\n * items, the status of the pagination, and a `loadMore` function.\n *\n * @public\n */\nexport function usePaginatedQuery<Query extends PaginatedQueryReference>(\n  query: Query,\n  args: PaginatedQueryArgs<Query> | \"skip\",\n  options: { initialNumItems: number },\n): UsePaginatedQueryReturnType<Query> {\n  if (\n    typeof options?.initialNumItems !== \"number\" ||\n    options.initialNumItems < 0\n  ) {\n    throw new Error(\n      `\\`options.initialNumItems\\` must be a positive number. Received \\`${options?.initialNumItems}\\`.`,\n    );\n  }\n  const skip = args === \"skip\";\n  const argsObject = skip ? {} : args;\n  const queryName = getFunctionName(query);\n  const createInitialState = useMemo(() => {\n    return () => {\n      const id = nextPaginationId();\n      return {\n        query,\n        args: argsObject as Record<string, Value>,\n        id,\n        nextPageKey: 1,\n        pageKeys: skip ? [] : [0],\n        queries: skip\n          ? ({} as UsePaginatedQueryState[\"queries\"])\n          : {\n              0: {\n                query,\n                args: {\n                  ...argsObject,\n                  paginationOpts: {\n                    numItems: options.initialNumItems,\n                    cursor: null,\n                    id,\n                  },\n                },\n              },\n            },\n        ongoingSplits: {},\n        skip,\n      };\n    };\n    // ESLint doesn't like that we're stringifying the args. We do this because\n    // we want to avoid rerendering if the args are a different\n    // object that serializes to the same result.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    JSON.stringify(convexToJson(argsObject as Value)),\n    queryName,\n    options.initialNumItems,\n    skip,\n  ]);\n\n  const [state, setState] =\n    useState<UsePaginatedQueryState>(createInitialState);\n\n  // `currState` is the state that we'll render based on.\n  let currState = state;\n  if (\n    getFunctionName(query) !== getFunctionName(state.query) ||\n    JSON.stringify(convexToJson(argsObject as Value)) !==\n      JSON.stringify(convexToJson(state.args)) ||\n    skip !== state.skip\n  ) {\n    currState = createInitialState();\n    setState(currState);\n  }\n\n  const resultsObject = useQueries(currState.queries);\n\n  const [results, maybeLastResult]: [\n    Value[],\n    undefined | PaginationResult<Value>,\n  ] = useMemo(() => {\n    let currResult = undefined;\n\n    const allItems = [];\n    for (const pageKey of currState.pageKeys) {\n      currResult = resultsObject[pageKey];\n      if (currResult === undefined) {\n        break;\n      }\n\n      if (currResult instanceof Error) {\n        if (currResult.message.includes(\"InvalidCursor\")) {\n          // - InvalidCursor: If the cursor is invalid, probably the paginated\n          // database query was data-dependent and changed underneath us. The\n          // cursor in the params or journal no longer matches the current\n          // database query.\n\n          // In all cases, we want to restart pagination to throw away all our\n          // existing cursors.\n          console.warn(\n            \"usePaginatedQuery hit error, resetting pagination state: \" +\n              currResult.message,\n          );\n          setState(createInitialState);\n          return [[], undefined];\n        } else {\n          throw currResult;\n        }\n      }\n      const ongoingSplit = currState.ongoingSplits[pageKey];\n      if (ongoingSplit !== undefined) {\n        if (\n          resultsObject[ongoingSplit[0]] !== undefined &&\n          resultsObject[ongoingSplit[1]] !== undefined\n        ) {\n          // Both pages of the split have results now. Swap them in.\n          setState(completeSplitQuery(pageKey));\n        }\n      } else if (\n        currResult.splitCursor &&\n        (currResult.pageStatus === \"SplitRecommended\" ||\n          currResult.pageStatus === \"SplitRequired\" ||\n          currResult.page.length > options.initialNumItems * 2)\n      ) {\n        // If a single page has more than double the expected number of items,\n        // or if the server requests a split, split the page into two.\n        setState(\n          splitQuery(\n            pageKey,\n            currResult.splitCursor,\n            currResult.continueCursor,\n          ),\n        );\n      }\n      if (currResult.pageStatus === \"SplitRequired\") {\n        // If pageStatus is 'SplitRequired', it means the server was not able to\n        // fetch the full page. So we stop results before the incomplete\n        // page and return 'LoadingMore' while the page is splitting.\n        return [allItems, undefined];\n      }\n      allItems.push(...currResult.page);\n    }\n    return [allItems, currResult];\n  }, [\n    resultsObject,\n    currState.pageKeys,\n    currState.ongoingSplits,\n    options.initialNumItems,\n    createInitialState,\n  ]);\n\n  const statusObject = useMemo(() => {\n    if (maybeLastResult === undefined) {\n      if (currState.nextPageKey === 1) {\n        return {\n          status: \"LoadingFirstPage\",\n          isLoading: true,\n          loadMore: (_numItems: number) => {\n            // Intentional noop.\n          },\n        } as const;\n      } else {\n        return {\n          status: \"LoadingMore\",\n          isLoading: true,\n          loadMore: (_numItems: number) => {\n            // Intentional noop.\n          },\n        } as const;\n      }\n    }\n    if (maybeLastResult.isDone) {\n      return {\n        status: \"Exhausted\",\n        isLoading: false,\n        loadMore: (_numItems: number) => {\n          // Intentional noop.\n        },\n      } as const;\n    }\n    const continueCursor = maybeLastResult.continueCursor;\n    let alreadyLoadingMore = false;\n    return {\n      status: \"CanLoadMore\",\n      isLoading: false,\n      loadMore: (numItems: number) => {\n        if (!alreadyLoadingMore) {\n          alreadyLoadingMore = true;\n          setState((prevState) => {\n            const pageKeys = [...prevState.pageKeys, prevState.nextPageKey];\n            const queries = { ...prevState.queries };\n            queries[prevState.nextPageKey] = {\n              query: prevState.query,\n              args: {\n                ...prevState.args,\n                paginationOpts: {\n                  numItems,\n                  cursor: continueCursor,\n                  id: prevState.id,\n                },\n              },\n            };\n            return {\n              ...prevState,\n              nextPageKey: prevState.nextPageKey + 1,\n              pageKeys,\n              queries,\n            };\n          });\n        }\n      },\n    } as const;\n  }, [maybeLastResult, currState.nextPageKey]);\n\n  return {\n    results,\n    ...statusObject,\n  };\n}\n\nlet paginationId = 0;\n/**\n * Generate a new, unique ID for a pagination session.\n *\n * Every usage of {@link usePaginatedQuery} puts a unique ID into the\n * query function arguments as a \"cache-buster\". This serves two purposes:\n *\n * 1. All calls to {@link usePaginatedQuery} have independent query\n * journals.\n *\n * Every time we start a new pagination session, we'll load the first page of\n * results and receive a fresh journal. Without the ID, we might instead reuse\n * a query subscription already present in our client. This isn't desirable\n * because the existing query function result may have grown or shrunk from the\n * requested `initialNumItems`.\n *\n * 2. We can restart the pagination session on some types of errors.\n *\n * Sometimes we want to restart pagination from the beginning if we hit an error.\n * Similar to (1), we'd like to ensure that this new session actually requests\n * its first page from the server and doesn't reuse a query result already\n * present in the client that may have hit the error.\n *\n * @returns The pagination ID.\n */\nfunction nextPaginationId(): number {\n  paginationId++;\n  return paginationId;\n}\n\n/**\n * Reset pagination id for tests only, so tests know what it is.\n */\nexport function resetPaginationId() {\n  paginationId = 0;\n}\n\n/**\n * The result of calling the {@link usePaginatedQuery} hook.\n *\n * This includes:\n * - `results` - An array of the currently loaded results.\n * - `isLoading` - Whether the hook is currently loading results.\n * - `status` - The status of the pagination. The possible statuses are:\n *   - \"LoadingFirstPage\": The hook is loading the first page of results.\n *   - \"CanLoadMore\": This query may have more items to fetch. Call `loadMore` to\n *   fetch another page.\n *   - \"LoadingMore\": We're currently loading another page of results.\n *   - \"Exhausted\": We've paginated to the end of the list.\n * - `loadMore(n)` A callback to fetch more results. This will only fetch more\n * results if the status is \"CanLoadMore\".\n *\n * @public\n */\nexport type UsePaginatedQueryResult<Item> = {\n  results: Item[];\n  loadMore: (numItems: number) => void;\n} & (\n  | {\n      status: \"LoadingFirstPage\";\n      isLoading: true;\n    }\n  | {\n      status: \"CanLoadMore\";\n      isLoading: false;\n    }\n  | {\n      status: \"LoadingMore\";\n      isLoading: true;\n    }\n  | {\n      status: \"Exhausted\";\n      isLoading: false;\n    }\n);\n\n/**\n * The possible pagination statuses in {@link UsePaginatedQueryResult}.\n *\n * This is a union of string literal types.\n * @public\n */\nexport type PaginationStatus = UsePaginatedQueryResult<any>[\"status\"];\n\n/**\n * Given a {@link PaginatedQueryReference}, get the type of the arguments\n * object for the query, excluding the `paginationOpts` argument.\n *\n * @public\n */\nexport type PaginatedQueryArgs<Query extends PaginatedQueryReference> = Expand<\n  BetterOmit<FunctionArgs<Query>, \"paginationOpts\">\n>;\n\n/**\n * Given a {@link PaginatedQueryReference}, get the type of the item being\n * paginated over.\n * @public\n */\nexport type PaginatedQueryItem<Query extends PaginatedQueryReference> =\n  FunctionReturnType<Query>[\"page\"][number];\n\n/**\n * The return type of {@link usePaginatedQuery}.\n *\n * @public\n */\nexport type UsePaginatedQueryReturnType<Query extends PaginatedQueryReference> =\n  UsePaginatedQueryResult<PaginatedQueryItem<Query>>;\n\n/**\n * Optimistically update the values in a paginated list.\n *\n * This optimistic update is designed to be used to update data loaded with\n * {@link usePaginatedQuery}. It updates the list by applying\n * `updateValue` to each element of the list across all of the loaded pages.\n *\n * This will only apply to queries with a matching names and arguments.\n *\n * Example usage:\n * ```ts\n * const myMutation = useMutation(api.myModule.myMutation)\n * .withOptimisticUpdate((localStore, mutationArg) => {\n *\n *   // Optimistically update the document with ID `mutationArg`\n *   // to have an additional property.\n *\n *   optimisticallyUpdateValueInPaginatedQuery(\n *     localStore,\n *     api.myModule.paginatedQuery\n *     {},\n *     currentValue => {\n *       if (mutationArg === currentValue._id) {\n *         return {\n *           ...currentValue,\n *           \"newProperty\": \"newValue\",\n *         };\n *       }\n *       return currentValue;\n *     }\n *   );\n *\n * });\n * ```\n *\n * @param localStore - An {@link OptimisticLocalStore} to update.\n * @param query - A {@link FunctionReference} for the paginated query to update.\n * @param args - The arguments object to the query function, excluding the\n * `paginationOpts` property.\n * @param updateValue - A function to produce the new values.\n *\n * @public\n */\nexport function optimisticallyUpdateValueInPaginatedQuery<\n  Query extends PaginatedQueryReference,\n>(\n  localStore: OptimisticLocalStore,\n  query: Query,\n  args: PaginatedQueryArgs<Query>,\n  updateValue: (\n    currentValue: PaginatedQueryItem<Query>,\n  ) => PaginatedQueryItem<Query>,\n): void {\n  const expectedArgs = JSON.stringify(convexToJson(args as Value));\n\n  for (const queryResult of localStore.getAllQueries(query)) {\n    if (queryResult.value !== undefined) {\n      const { paginationOpts: _, ...innerArgs } = queryResult.args as {\n        paginationOpts: PaginationOptions;\n      };\n      if (JSON.stringify(convexToJson(innerArgs as Value)) === expectedArgs) {\n        const value = queryResult.value;\n        if (\n          typeof value === \"object\" &&\n          value !== null &&\n          Array.isArray(value.page)\n        ) {\n          localStore.setQuery(query, queryResult.args, {\n            ...value,\n            page: value.page.map(updateValue),\n          });\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}