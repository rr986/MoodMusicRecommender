{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport jwtDecode from \"jwt-decode\";\nconst MAXIMUM_REFRESH_DELAY = 20 * 24 * 60 * 60 * 1e3;\nexport class AuthenticationManager {\n  constructor(syncState, _ref) {\n    let {\n      authenticate,\n      stopSocket,\n      restartSocket,\n      pauseSocket,\n      resumeSocket,\n      clearAuth,\n      verbose\n    } = _ref;\n    __publicField(this, \"authState\", {\n      state: \"noAuth\"\n    });\n    // Used to detect races involving `setConfig` calls\n    // while a token is being fetched.\n    __publicField(this, \"configVersion\", 0);\n    // Shared by the BaseClient so that the auth manager can easily inspect it\n    __publicField(this, \"syncState\");\n    // Passed down by BaseClient, sends a message to the server\n    __publicField(this, \"authenticate\");\n    __publicField(this, \"stopSocket\");\n    __publicField(this, \"restartSocket\");\n    __publicField(this, \"pauseSocket\");\n    __publicField(this, \"resumeSocket\");\n    // Passed down by BaseClient, sends a message to the server\n    __publicField(this, \"clearAuth\");\n    __publicField(this, \"verbose\");\n    this.syncState = syncState;\n    this.authenticate = authenticate;\n    this.stopSocket = stopSocket;\n    this.restartSocket = restartSocket;\n    this.pauseSocket = pauseSocket;\n    this.resumeSocket = resumeSocket;\n    this.clearAuth = clearAuth;\n    this.verbose = verbose;\n  }\n  async setConfig(fetchToken, onChange) {\n    this.resetAuthState();\n    this._logVerbose(\"pausing WS for auth token fetch\");\n    this.pauseSocket();\n    const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {\n      forceRefreshToken: false\n    });\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n    if (token.value) {\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfCachedToken\",\n        config: {\n          fetchToken,\n          onAuthChange: onChange\n        },\n        hasRetried: false\n      });\n      this.authenticate(token.value);\n      this._logVerbose(\"resuming WS after auth token fetch\");\n      this.resumeSocket();\n    } else {\n      this.setAuthState({\n        state: \"initialRefetch\",\n        config: {\n          fetchToken,\n          onAuthChange: onChange\n        }\n      });\n      await this.refetchToken();\n    }\n  }\n  onTransition(serverMessage) {\n    if (!this.syncState.isCurrentOrNewerAuthVersion(serverMessage.endVersion.identity)) {\n      return;\n    }\n    if (serverMessage.endVersion.identity <= serverMessage.startVersion.identity) {\n      return;\n    }\n    if (this.authState.state === \"waitingForServerConfirmationOfCachedToken\") {\n      this._logVerbose(\"server confirmed auth token is valid\");\n      void this.refetchToken();\n      this.authState.config.onAuthChange(true);\n      return;\n    }\n    if (this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n      this._logVerbose(\"server confirmed new auth token is valid\");\n      this.scheduleTokenRefetch(this.authState.token);\n      if (!this.authState.hadAuth) {\n        this.authState.config.onAuthChange(true);\n      }\n    }\n  }\n  onAuthError(serverMessage) {\n    const {\n      baseVersion\n    } = serverMessage;\n    if (baseVersion !== null && baseVersion !== void 0) {\n      if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {\n        this._logVerbose(\"ignoring auth error for previous auth attempt\");\n        return;\n      }\n      void this.tryToReauthenticate(serverMessage);\n      return;\n    }\n    void this.tryToReauthenticate(serverMessage);\n  }\n  // This is similar to `refetchToken` defined below, in fact we\n  // don't represent them as different states, but it is different\n  // in that we pause the WebSocket so that mutations\n  // don't retry with bad auth.\n  async tryToReauthenticate(serverMessage) {\n    if (\n    // No way to fetch another token, kaboom\n    this.authState.state === \"noAuth\" ||\n    // We failed on a fresh token, trying another one won't help\n    this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n      console.error(`Failed to authenticate: \"${serverMessage.error}\", check your server auth config`);\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      if (this.authState.state !== \"noAuth\") {\n        this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n      }\n      return;\n    }\n    this._logVerbose(\"attempting to reauthenticate\");\n    await this.stopSocket();\n    const token = await this.fetchTokenAndGuardAgainstRace(this.authState.config.fetchToken, {\n      forceRefreshToken: true\n    });\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n    if (token.value && this.syncState.isNewAuth(token.value)) {\n      this.authenticate(token.value);\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfFreshToken\",\n        config: this.authState.config,\n        token: token.value,\n        hadAuth: this.authState.state === \"notRefetching\" || this.authState.state === \"waitingForScheduledRefetch\"\n      });\n    } else {\n      this._logVerbose(\"reauthentication failed, could not fetch a new token\");\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n    this.restartSocket();\n  }\n  // Force refetch the token and schedule another refetch\n  // before the token expires - an active client should never\n  // need to reauthenticate.\n  async refetchToken() {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    this._logVerbose(\"refetching auth token\");\n    const token = await this.fetchTokenAndGuardAgainstRace(this.authState.config.fetchToken, {\n      forceRefreshToken: true\n    });\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n    if (token.value) {\n      if (this.syncState.isNewAuth(token.value)) {\n        this.setAuthState({\n          state: \"waitingForServerConfirmationOfFreshToken\",\n          hadAuth: this.syncState.hasAuth(),\n          token: token.value,\n          config: this.authState.config\n        });\n        this.authenticate(token.value);\n      } else {\n        this.setAuthState({\n          state: \"notRefetching\",\n          config: this.authState.config\n        });\n      }\n    } else {\n      this._logVerbose(\"refetching token failed\");\n      if (this.syncState.hasAuth()) {\n        this.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n    this._logVerbose(\"resuming WS after auth token fetch (if currently paused)\");\n    this.resumeSocket();\n  }\n  scheduleTokenRefetch(token) {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    const decodedToken = this.decodeToken(token);\n    if (!decodedToken) {\n      console.error(\"Auth token is not a valid JWT, cannot refetch the token\");\n      return;\n    }\n    const {\n      iat,\n      exp\n    } = decodedToken;\n    if (!iat || !exp) {\n      console.error(\"Auth token does not have required fields, cannot refetch the token\");\n      return;\n    }\n    const leewaySeconds = 2;\n    const delay = Math.min(MAXIMUM_REFRESH_DELAY, (exp - iat - leewaySeconds) * 1e3);\n    if (delay <= 0) {\n      console.error(\"Auth token does not live long enough, cannot refetch the token\");\n      return;\n    }\n    const refetchTokenTimeoutId = setTimeout(() => {\n      void this.refetchToken();\n    }, delay);\n    this.setAuthState({\n      state: \"waitingForScheduledRefetch\",\n      refetchTokenTimeoutId,\n      config: this.authState.config\n    });\n    this._logVerbose(`scheduled preemptive auth token refetching in ${delay}ms`);\n  }\n  // Protects against simultaneous calls to `setConfig`\n  // while we're fetching a token\n  async fetchTokenAndGuardAgainstRace(fetchToken, fetchArgs) {\n    const originalConfigVersion = ++this.configVersion;\n    const token = await fetchToken(fetchArgs);\n    if (this.configVersion !== originalConfigVersion) {\n      return {\n        isFromOutdatedConfig: true\n      };\n    }\n    return {\n      isFromOutdatedConfig: false,\n      value: token\n    };\n  }\n  stop() {\n    this.resetAuthState();\n    this.configVersion++;\n  }\n  setAndReportAuthFailed(onAuthChange) {\n    onAuthChange(false);\n    this.resetAuthState();\n  }\n  resetAuthState() {\n    this.setAuthState({\n      state: \"noAuth\"\n    });\n  }\n  setAuthState(newAuth) {\n    if (this.authState.state === \"waitingForScheduledRefetch\") {\n      clearTimeout(this.authState.refetchTokenTimeoutId);\n      this.syncState.markAuthCompletion();\n    }\n    this.authState = newAuth;\n  }\n  decodeToken(token) {\n    try {\n      return jwtDecode(token);\n    } catch (e) {\n      return null;\n    }\n  }\n  _logVerbose(message) {\n    if (this.verbose) {\n      console.debug(`${(/* @__PURE__ */new Date()).toISOString()} ${message} [v${this.configVersion}]`);\n    }\n  }\n}","map":{"version":3,"names":["jwtDecode","MAXIMUM_REFRESH_DELAY","AuthenticationManager","constructor","syncState","_ref","authenticate","stopSocket","restartSocket","pauseSocket","resumeSocket","clearAuth","verbose","__publicField","state","setConfig","fetchToken","onChange","resetAuthState","_logVerbose","token","fetchTokenAndGuardAgainstRace","forceRefreshToken","isFromOutdatedConfig","value","setAuthState","config","onAuthChange","hasRetried","refetchToken","onTransition","serverMessage","isCurrentOrNewerAuthVersion","endVersion","identity","startVersion","authState","scheduleTokenRefetch","hadAuth","onAuthError","baseVersion","tryToReauthenticate","console","error","hasAuth","setAndReportAuthFailed","isNewAuth","decodedToken","decodeToken","iat","exp","leewaySeconds","delay","Math","min","refetchTokenTimeoutId","setTimeout","fetchArgs","originalConfigVersion","configVersion","stop","newAuth","clearTimeout","markAuthCompletion","e","message","debug","Date","toISOString"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/browser/sync/authentication_manager.ts"],"sourcesContent":["import { LocalSyncState } from \"./local_state.js\";\nimport { AuthError, Transition } from \"./protocol.js\";\nimport jwtDecode from \"jwt-decode\";\n\n// setTimout uses 32 bit integer, so it can only\n// schedule about 24 days in the future.\nconst MAXIMUM_REFRESH_DELAY = 20 * 24 * 60 * 60 * 1000; // 20 days\n\n/**\n * An async function returning the JWT-encoded OpenID Connect Identity Token\n * if available.\n *\n * `forceRefreshToken` is `true` if the server rejected a previously\n * returned token, and the client should try to fetch a new one.\n *\n * See {@link ConvexReactClient.setAuth}.\n *\n * @public\n */\nexport type AuthTokenFetcher = (args: {\n  forceRefreshToken: boolean;\n}) => Promise<string | null | undefined>;\n\n/**\n * What is provided to the client.\n */\ntype AuthConfig = {\n  fetchToken: AuthTokenFetcher;\n  onAuthChange: (isAuthenticated: boolean) => void;\n};\n\n/**\n * In general we take 3 steps:\n *   1. Fetch a possibly cached token\n *   2. Immediately fetch a fresh token without using a cache\n *   3. Repeat step 2 before the end of the fresh token's lifetime\n *\n * When we fetch without using a cache we know when the token\n * will expire, and can schedule refetching it.\n *\n * If we get an error before a scheduled refetch, we go back\n * to step 2.\n */\ntype AuthState =\n  | { state: \"noAuth\" }\n  | {\n      state: \"waitingForServerConfirmationOfCachedToken\";\n      config: AuthConfig;\n      hasRetried: boolean;\n    }\n  | {\n      state: \"initialRefetch\";\n      config: AuthConfig;\n    }\n  | {\n      state: \"waitingForServerConfirmationOfFreshToken\";\n      config: AuthConfig;\n      hadAuth: boolean;\n      token: string;\n    }\n  | {\n      state: \"waitingForScheduledRefetch\";\n      config: AuthConfig;\n      refetchTokenTimeoutId: ReturnType<typeof setTimeout>;\n    }\n  // Special/weird state when we got a valid token\n  // but could not fetch a new one.\n  | {\n      state: \"notRefetching\";\n      config: AuthConfig;\n    };\n\n/**\n * Handles the state transitions for auth. The server is the source\n * of truth.\n */\nexport class AuthenticationManager {\n  private authState: AuthState = { state: \"noAuth\" };\n  // Used to detect races involving `setConfig` calls\n  // while a token is being fetched.\n  private configVersion = 0;\n  // Shared by the BaseClient so that the auth manager can easily inspect it\n  private readonly syncState: LocalSyncState;\n  // Passed down by BaseClient, sends a message to the server\n  private readonly authenticate: (token: string) => void;\n  private readonly stopSocket: () => Promise<void>;\n  private readonly restartSocket: () => void;\n  private readonly pauseSocket: () => void;\n  private readonly resumeSocket: () => void;\n  // Passed down by BaseClient, sends a message to the server\n  private readonly clearAuth: () => void;\n  private readonly verbose: boolean;\n\n  constructor(\n    syncState: LocalSyncState,\n    {\n      authenticate,\n      stopSocket,\n      restartSocket,\n      pauseSocket,\n      resumeSocket,\n      clearAuth,\n      verbose,\n    }: {\n      authenticate: (token: string) => void;\n      stopSocket: () => Promise<void>;\n      restartSocket: () => void;\n      pauseSocket: () => void;\n      resumeSocket: () => void;\n      clearAuth: () => void;\n      verbose: boolean;\n    },\n  ) {\n    this.syncState = syncState;\n    this.authenticate = authenticate;\n    this.stopSocket = stopSocket;\n    this.restartSocket = restartSocket;\n    this.pauseSocket = pauseSocket;\n    this.resumeSocket = resumeSocket;\n    this.clearAuth = clearAuth;\n    this.verbose = verbose;\n  }\n\n  async setConfig(\n    fetchToken: AuthTokenFetcher,\n    onChange: (isAuthenticated: boolean) => void,\n  ) {\n    this.resetAuthState();\n    this._logVerbose(\"pausing WS for auth token fetch\");\n    this.pauseSocket();\n    const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {\n      forceRefreshToken: false,\n    });\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n    if (token.value) {\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfCachedToken\",\n        config: { fetchToken, onAuthChange: onChange },\n        hasRetried: false,\n      });\n      this.authenticate(token.value);\n      this._logVerbose(\"resuming WS after auth token fetch\");\n      this.resumeSocket();\n    } else {\n      this.setAuthState({\n        state: \"initialRefetch\",\n        config: { fetchToken, onAuthChange: onChange },\n      });\n      // Try again with `forceRefreshToken: true`\n      await this.refetchToken();\n    }\n  }\n\n  onTransition(serverMessage: Transition) {\n    if (\n      !this.syncState.isCurrentOrNewerAuthVersion(\n        serverMessage.endVersion.identity,\n      )\n    ) {\n      // This is a stale transition - client has moved on to\n      // a newer auth version.\n      return;\n    }\n    if (\n      serverMessage.endVersion.identity <= serverMessage.startVersion.identity\n    ) {\n      // This transition did not change auth - it is not a response to Authenticate.\n      return;\n    }\n\n    if (this.authState.state === \"waitingForServerConfirmationOfCachedToken\") {\n      this._logVerbose(\"server confirmed auth token is valid\");\n      void this.refetchToken();\n      this.authState.config.onAuthChange(true);\n      return;\n    }\n    if (this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n      this._logVerbose(\"server confirmed new auth token is valid\");\n      this.scheduleTokenRefetch(this.authState.token);\n      if (!this.authState.hadAuth) {\n        this.authState.config.onAuthChange(true);\n      }\n    }\n  }\n\n  onAuthError(serverMessage: AuthError) {\n    const { baseVersion } = serverMessage;\n    // Versioned AuthErrors are ignored if the client advanced to\n    // a newer auth identity\n    if (baseVersion !== null && baseVersion !== undefined) {\n      // Error are reporting the previous version, since the server\n      // didn't advance, hence `+ 1`.\n      if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {\n        this._logVerbose(\"ignoring auth error for previous auth attempt\");\n        return;\n      }\n      void this.tryToReauthenticate(serverMessage);\n      return;\n    }\n\n    // TODO: Remove after all AuthErrors are versioned\n    void this.tryToReauthenticate(serverMessage);\n  }\n\n  // This is similar to `refetchToken` defined below, in fact we\n  // don't represent them as different states, but it is different\n  // in that we pause the WebSocket so that mutations\n  // don't retry with bad auth.\n  private async tryToReauthenticate(serverMessage: AuthError) {\n    // We only retry once, to avoid infinite retries\n    if (\n      // No way to fetch another token, kaboom\n      this.authState.state === \"noAuth\" ||\n      // We failed on a fresh token, trying another one won't help\n      this.authState.state === \"waitingForServerConfirmationOfFreshToken\"\n    ) {\n      console.error(\n        `Failed to authenticate: \"${serverMessage.error}\", check your server auth config`,\n      );\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      if (this.authState.state !== \"noAuth\") {\n        this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n      }\n      return;\n    }\n    this._logVerbose(\"attempting to reauthenticate\");\n    await this.stopSocket();\n    const token = await this.fetchTokenAndGuardAgainstRace(\n      this.authState.config.fetchToken,\n      {\n        forceRefreshToken: true,\n      },\n    );\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n\n    if (token.value && this.syncState.isNewAuth(token.value)) {\n      this.authenticate(token.value);\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfFreshToken\",\n        config: this.authState.config,\n        token: token.value,\n        hadAuth:\n          this.authState.state === \"notRefetching\" ||\n          this.authState.state === \"waitingForScheduledRefetch\",\n      });\n    } else {\n      this._logVerbose(\"reauthentication failed, could not fetch a new token\");\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n    this.restartSocket();\n  }\n\n  // Force refetch the token and schedule another refetch\n  // before the token expires - an active client should never\n  // need to reauthenticate.\n  private async refetchToken() {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    this._logVerbose(\"refetching auth token\");\n    const token = await this.fetchTokenAndGuardAgainstRace(\n      this.authState.config.fetchToken,\n      {\n        forceRefreshToken: true,\n      },\n    );\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n\n    if (token.value) {\n      if (this.syncState.isNewAuth(token.value)) {\n        this.setAuthState({\n          state: \"waitingForServerConfirmationOfFreshToken\",\n          hadAuth: this.syncState.hasAuth(),\n          token: token.value,\n          config: this.authState.config,\n        });\n        this.authenticate(token.value);\n      } else {\n        this.setAuthState({\n          state: \"notRefetching\",\n          config: this.authState.config,\n        });\n      }\n    } else {\n      this._logVerbose(\"refetching token failed\");\n      if (this.syncState.hasAuth()) {\n        this.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n    // Resuming in case this refetch was triggered\n    // by an invalid cached token.\n    this._logVerbose(\n      \"resuming WS after auth token fetch (if currently paused)\",\n    );\n    this.resumeSocket();\n  }\n\n  private scheduleTokenRefetch(token: string) {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    const decodedToken = this.decodeToken(token);\n    if (!decodedToken) {\n      // This is no longer really possible, because\n      // we wait on server response before scheduling token refetch,\n      // and the server currently requires JWT tokens.\n      console.error(\"Auth token is not a valid JWT, cannot refetch the token\");\n      return;\n    }\n    // iat: issued at time, UTC seconds timestamp at which the JWT was issued\n    // exp: expiration time, UTC seconds timestamp at which the JWT will expire\n    const { iat, exp } = decodedToken as { iat?: number; exp?: number };\n    if (!iat || !exp) {\n      console.error(\n        \"Auth token does not have required fields, cannot refetch the token\",\n      );\n      return;\n    }\n    const leewaySeconds = 2;\n    // Because the client and server clocks may be out of sync,\n    // we only know that the token will expire after `exp - iat`,\n    // and since we just fetched a fresh one we know when that\n    // will happen.\n    const delay = Math.min(\n      MAXIMUM_REFRESH_DELAY,\n      (exp - iat - leewaySeconds) * 1000,\n    );\n    if (delay <= 0) {\n      console.error(\n        \"Auth token does not live long enough, cannot refetch the token\",\n      );\n      return;\n    }\n    const refetchTokenTimeoutId = setTimeout(() => {\n      void this.refetchToken();\n    }, delay);\n    this.setAuthState({\n      state: \"waitingForScheduledRefetch\",\n      refetchTokenTimeoutId,\n      config: this.authState.config,\n    });\n    this._logVerbose(\n      `scheduled preemptive auth token refetching in ${delay}ms`,\n    );\n  }\n\n  // Protects against simultaneous calls to `setConfig`\n  // while we're fetching a token\n  private async fetchTokenAndGuardAgainstRace(\n    fetchToken: AuthTokenFetcher,\n    fetchArgs: {\n      forceRefreshToken: boolean;\n    },\n  ) {\n    const originalConfigVersion = ++this.configVersion;\n    const token = await fetchToken(fetchArgs);\n    if (this.configVersion !== originalConfigVersion) {\n      // This is a stale config\n      return { isFromOutdatedConfig: true };\n    }\n    return { isFromOutdatedConfig: false, value: token };\n  }\n\n  stop() {\n    this.resetAuthState();\n    // Bump this in case we are mid-token-fetch when we get stopped\n    this.configVersion++;\n  }\n\n  private setAndReportAuthFailed(\n    onAuthChange: (authenticated: boolean) => void,\n  ) {\n    onAuthChange(false);\n    this.resetAuthState();\n  }\n\n  private resetAuthState() {\n    this.setAuthState({ state: \"noAuth\" });\n  }\n\n  private setAuthState(newAuth: AuthState) {\n    if (this.authState.state === \"waitingForScheduledRefetch\") {\n      clearTimeout(this.authState.refetchTokenTimeoutId);\n\n      // The waitingForScheduledRefetch state is the most quiesced authed state.\n      // Let the syncState know that auth is in a good state, so it can reset failure backoffs\n      this.syncState.markAuthCompletion();\n    }\n    this.authState = newAuth;\n  }\n\n  private decodeToken(token: string) {\n    try {\n      return jwtDecode(token);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  private _logVerbose(message: string) {\n    if (this.verbose) {\n      console.debug(\n        `${new Date().toISOString()} ${message} [v${this.configVersion}]`,\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}