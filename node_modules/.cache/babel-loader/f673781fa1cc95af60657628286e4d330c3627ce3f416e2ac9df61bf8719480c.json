{"ast":null,"code":"\"use strict\";\n\nimport * as Base64 from \"./base64.js\";\nimport { isSimpleObject } from \"../common/index.js\";\nconst LITTLE_ENDIAN = true;\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\nfunction isSpecial(n) {\n  return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\nexport function slowBigIntToBase64(value) {\n  if (value < ZERO) {\n    value -= MIN_INT64 + MIN_INT64;\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2 === 1) hex = \"0\" + hex;\n  const bytes = new Uint8Array(new ArrayBuffer(8));\n  let i = 0;\n  for (const hexByte of hex.match(/.{2}/g).reverse()) {\n    bytes.set([parseInt(hexByte, 16)], i++);\n    value >>= EIGHT;\n  }\n  return Base64.fromByteArray(bytes);\n}\nexport function slowBase64ToBigInt(encoded) {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(`Received ${integerBytes.byteLength} bytes, expected 8 for $integer`);\n  }\n  let value = ZERO;\n  let power = ZERO;\n  for (const byte of integerBytes) {\n    value += BigInt(byte) * TWOFIFTYSIX ** power;\n    power++;\n  }\n  if (value > MAX_INT64) {\n    value += MIN_INT64 + MIN_INT64;\n  }\n  return value;\n}\nexport function modernBigIntToBase64(value) {\n  if (value < MIN_INT64 || MAX_INT64 < value) {\n    throw new Error(`BigInt ${value} does not fit into a 64-bit signed integer.`);\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigInt64(0, value, true);\n  return Base64.fromByteArray(new Uint8Array(buffer));\n}\nexport function modernBase64ToBigInt(encoded) {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(`Received ${integerBytes.byteLength} bytes, expected 8 for $integer`);\n  }\n  const intBytesView = new DataView(integerBytes.buffer);\n  return intBytesView.getBigInt64(0, true);\n}\nexport const bigIntToBase64 = DataView.prototype.setBigInt64 ? modernBigIntToBase64 : slowBigIntToBase64;\nexport const base64ToBigInt = DataView.prototype.getBigInt64 ? modernBase64ToBigInt : slowBase64ToBigInt;\nconst MAX_IDENTIFIER_LEN = 1024;\nfunction validateObjectField(k) {\n  if (k.length > MAX_IDENTIFIER_LEN) {\n    throw new Error(`Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`);\n  }\n  if (k.startsWith(\"$\")) {\n    throw new Error(`Field name ${k} starts with a '$', which is reserved.`);\n  }\n  for (let i = 0; i < k.length; i += 1) {\n    const charCode = k.charCodeAt(i);\n    if (charCode < 32 || charCode >= 127) {\n      throw new Error(`Field name ${k} has invalid character '${k[i]}': Field names can only contain non-control ASCII characters`);\n    }\n  }\n}\nexport function jsonToConvex(value) {\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map(value2 => jsonToConvex(value2));\n  }\n  if (typeof value !== \"object\") {\n    throw new Error(`Unexpected type of ${value}`);\n  }\n  const entries = Object.entries(value);\n  if (entries.length === 1) {\n    const key = entries[0][0];\n    if (key === \"$bytes\") {\n      if (typeof value.$bytes !== \"string\") {\n        throw new Error(`Malformed $bytes field on ${value}`);\n      }\n      return Base64.toByteArray(value.$bytes).buffer;\n    }\n    if (key === \"$integer\") {\n      if (typeof value.$integer !== \"string\") {\n        throw new Error(`Malformed $integer field on ${value}`);\n      }\n      return base64ToBigInt(value.$integer);\n    }\n    if (key === \"$float\") {\n      if (typeof value.$float !== \"string\") {\n        throw new Error(`Malformed $float field on ${value}`);\n      }\n      const floatBytes = Base64.toByteArray(value.$float);\n      if (floatBytes.byteLength !== 8) {\n        throw new Error(`Received ${floatBytes.byteLength} bytes, expected 8 for $float`);\n      }\n      const floatBytesView = new DataView(floatBytes.buffer);\n      const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n      if (!isSpecial(float)) {\n        throw new Error(`Float ${float} should be encoded as a number`);\n      }\n      return float;\n    }\n    if (key === \"$set\") {\n      throw new Error(`Received a Set which is no longer supported as a Convex type.`);\n    }\n    if (key === \"$map\") {\n      throw new Error(`Received a Map which is no longer supported as a Convex type.`);\n    }\n  }\n  const out = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = jsonToConvex(v);\n  }\n  return out;\n}\nexport function stringifyValueForError(value) {\n  return JSON.stringify(value, (_key, value2) => {\n    if (value2 === void 0) {\n      return \"undefined\";\n    }\n    if (typeof value2 === \"bigint\") {\n      return `${value2.toString()}n`;\n    }\n    return value2;\n  });\n}\nfunction convexToJsonInternal(value, originalValue, context, includeTopLevelUndefined) {\n  if (value === void 0) {\n    const contextText = context && ` (present at path ${context} in original object ${stringifyValueForError(originalValue)})`;\n    throw new Error(`undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`);\n  }\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"bigint\") {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n      throw new Error(`BigInt ${value} does not fit into a 64-bit signed integer.`);\n    }\n    return {\n      $integer: bigIntToBase64(value)\n    };\n  }\n  if (typeof value === \"number\") {\n    if (isSpecial(value)) {\n      const buffer = new ArrayBuffer(8);\n      new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n      return {\n        $float: Base64.fromByteArray(new Uint8Array(buffer))\n      };\n    } else {\n      return value;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    return {\n      $bytes: Base64.fromByteArray(new Uint8Array(value))\n    };\n  }\n  if (Array.isArray(value)) {\n    return value.map((value2, i) => convexToJsonInternal(value2, originalValue, context + `[${i}]`, false));\n  }\n  if (value instanceof Set) {\n    throw new Error(errorMessageForUnsupportedType(context, \"Set\", [...value], originalValue));\n  }\n  if (value instanceof Map) {\n    throw new Error(errorMessageForUnsupportedType(context, \"Map\", [...value], originalValue));\n  }\n  if (!isSimpleObject(value)) {\n    const theType = value?.constructor?.name;\n    const typeName = theType ? `${theType} ` : \"\";\n    throw new Error(errorMessageForUnsupportedType(context, typeName, value, originalValue));\n  }\n  const out = {};\n  const entries = Object.entries(value);\n  entries.sort((_ref, _ref2) => {\n    let [k1, _v1] = _ref;\n    let [k2, _v2] = _ref2;\n    return k1 === k2 ? 0 : k1 < k2 ? -1 : 1;\n  });\n  for (const [k, v] of entries) {\n    if (v !== void 0) {\n      validateObjectField(k);\n      out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`, false);\n    } else if (includeTopLevelUndefined) {\n      validateObjectField(k);\n      out[k] = convexOrUndefinedToJsonInternal(v, originalValue, context + `.${k}`);\n    }\n  }\n  return out;\n}\nfunction errorMessageForUnsupportedType(context, typeName, value, originalValue) {\n  if (context) {\n    return `${typeName}${stringifyValueForError(value)} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(originalValue)}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`;\n  } else {\n    return `${typeName}${stringifyValueForError(value)} is not a supported Convex type.`;\n  }\n}\nfunction convexOrUndefinedToJsonInternal(value, originalValue, context) {\n  if (value === void 0) {\n    return {\n      $undefined: null\n    };\n  } else {\n    if (originalValue === void 0) {\n      throw new Error(`Programming error. Current value is ${stringifyValueForError(value)} but original value is undefined`);\n    }\n    return convexToJsonInternal(value, originalValue, context, false);\n  }\n}\nexport function convexToJson(value) {\n  return convexToJsonInternal(value, value, \"\", false);\n}\nexport function convexOrUndefinedToJson(value) {\n  return convexOrUndefinedToJsonInternal(value, value, \"\");\n}\nexport function patchValueToJson(value) {\n  return convexToJsonInternal(value, value, \"\", true);\n}","map":{"version":3,"names":["Base64","isSimpleObject","LITTLE_ENDIAN","MIN_INT64","BigInt","MAX_INT64","ZERO","EIGHT","TWOFIFTYSIX","isSpecial","n","Number","isNaN","isFinite","Object","is","slowBigIntToBase64","value","hex","toString","length","bytes","Uint8Array","ArrayBuffer","i","hexByte","match","reverse","set","parseInt","fromByteArray","slowBase64ToBigInt","encoded","integerBytes","toByteArray","byteLength","Error","power","byte","modernBigIntToBase64","buffer","DataView","setBigInt64","modernBase64ToBigInt","intBytesView","getBigInt64","bigIntToBase64","prototype","base64ToBigInt","MAX_IDENTIFIER_LEN","validateObjectField","k","startsWith","charCode","charCodeAt","jsonToConvex","Array","isArray","map","value2","entries","key","$bytes","$integer","$float","floatBytes","floatBytesView","float","getFloat64","out","v","stringifyValueForError","JSON","stringify","_key","convexToJsonInternal","originalValue","context","includeTopLevelUndefined","contextText","setFloat64","Set","errorMessageForUnsupportedType","Map","theType","constructor","name","typeName","sort","_ref","_ref2","k1","_v1","k2","_v2","convexOrUndefinedToJsonInternal","$undefined","convexToJson","convexOrUndefinedToJson","patchValueToJson"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/values/value.ts"],"sourcesContent":["/**\n * Utilities for working with values stored in Convex.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n * @module\n */\nimport * as Base64 from \"./base64.js\";\nimport { isSimpleObject } from \"../common/index.js\";\n\nconst LITTLE_ENDIAN = true;\n// This code is used by code that may not have bigint literals.\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\n\n/**\n * The type of JavaScript values serializable to JSON.\n *\n * @public\n */\nexport type JSONValue =\n  | null\n  | boolean\n  | number\n  | string\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\n/**\n * An identifier for a document in Convex.\n *\n * Convex documents are uniquely identified by their `Id`, which is accessible\n * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/database/document-ids).\n *\n * Documents can be loaded using `db.get(id)` in query and mutation functions.\n *\n * IDs are base 32 encoded strings which are URL safe.\n *\n * IDs are just strings at runtime, but this type can be used to distinguish them from other\n * strings at compile time.\n *\n * If you're using code generation, use the `Id` type generated for your data model in\n * `convex/_generated/dataModel.d.ts`.\n *\n * @typeParam TableName - A string literal type of the table name (like \"users\").\n *\n * @public\n */\nexport type Id<TableName extends string> = string & { __tableName: TableName };\n\n/**\n * A value supported by Convex.\n *\n * Values can be:\n * - stored inside of documents.\n * - used as arguments and return types to queries and mutation functions.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n *\n * @public\n */\nexport type Value =\n  | null\n  | bigint\n  | number\n  | boolean\n  | string\n  | ArrayBuffer\n  | Value[]\n  | { [key: string]: undefined | Value };\n\n/**\n * The types of {@link Value} that can be used to represent numbers.\n *\n * @public\n */\nexport type NumericValue = bigint | number;\n\nfunction isSpecial(n: number) {\n  return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\n\nexport function slowBigIntToBase64(value: bigint): string {\n  // the conversion is easy if we pretend it's unsigned\n  if (value < ZERO) {\n    value -= MIN_INT64 + MIN_INT64;\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2 === 1) hex = \"0\" + hex;\n\n  const bytes = new Uint8Array(new ArrayBuffer(8));\n  let i = 0;\n  for (const hexByte of hex.match(/.{2}/g)!.reverse()) {\n    bytes.set([parseInt(hexByte, 16)], i++);\n    value >>= EIGHT;\n  }\n  return Base64.fromByteArray(bytes);\n}\n\nexport function slowBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`,\n    );\n  }\n  let value = ZERO;\n  let power = ZERO;\n  for (const byte of integerBytes) {\n    value += BigInt(byte) * TWOFIFTYSIX ** power;\n    power++;\n  }\n  if (value > MAX_INT64) {\n    value += MIN_INT64 + MIN_INT64;\n  }\n  return value;\n}\n\nexport function modernBigIntToBase64(value: bigint): string {\n  if (value < MIN_INT64 || MAX_INT64 < value) {\n    throw new Error(\n      `BigInt ${value} does not fit into a 64-bit signed integer.`,\n    );\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigInt64(0, value, true);\n  return Base64.fromByteArray(new Uint8Array(buffer));\n}\n\nexport function modernBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`,\n    );\n  }\n  const intBytesView = new DataView(integerBytes.buffer);\n  return intBytesView.getBigInt64(0, true);\n}\n\n// Fall back to a slower version on Safari 14 which lacks these APIs.\nexport const bigIntToBase64 = (DataView.prototype as any).setBigInt64\n  ? modernBigIntToBase64\n  : slowBigIntToBase64;\nexport const base64ToBigInt = (DataView.prototype as any).getBigInt64\n  ? modernBase64ToBigInt\n  : slowBase64ToBigInt;\n\nconst MAX_IDENTIFIER_LEN = 1024;\n\nfunction validateObjectField(k: string) {\n  if (k.length > MAX_IDENTIFIER_LEN) {\n    throw new Error(\n      `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`,\n    );\n  }\n  if (k.startsWith(\"$\")) {\n    throw new Error(`Field name ${k} starts with a '$', which is reserved.`);\n  }\n  for (let i = 0; i < k.length; i += 1) {\n    const charCode = k.charCodeAt(i);\n    // Non-control ASCII characters\n    if (charCode < 32 || charCode >= 127) {\n      throw new Error(\n        `Field name ${k} has invalid character '${k[i]}': Field names can only contain non-control ASCII characters`,\n      );\n    }\n  }\n}\n\n/**\n * Parse a Convex value from its JSON representation.\n *\n * This function will deserialize serialized Int64s to `BigInt`s, Bytes to `ArrayBuffer`s etc.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - The JSON representation of a Convex value previously created with {@link convexToJson}.\n * @returns The JavaScript representation of the Convex value.\n *\n * @public\n */\nexport function jsonToConvex(value: JSONValue): Value {\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map((value) => jsonToConvex(value));\n  }\n  if (typeof value !== \"object\") {\n    throw new Error(`Unexpected type of ${value as any}`);\n  }\n  const entries = Object.entries(value);\n  if (entries.length === 1) {\n    const key = entries[0][0];\n    if (key === \"$bytes\") {\n      if (typeof value.$bytes !== \"string\") {\n        throw new Error(`Malformed $bytes field on ${value as any}`);\n      }\n      return Base64.toByteArray(value.$bytes).buffer;\n    }\n    if (key === \"$integer\") {\n      if (typeof value.$integer !== \"string\") {\n        throw new Error(`Malformed $integer field on ${value as any}`);\n      }\n      return base64ToBigInt(value.$integer);\n    }\n    if (key === \"$float\") {\n      if (typeof value.$float !== \"string\") {\n        throw new Error(`Malformed $float field on ${value as any}`);\n      }\n      const floatBytes = Base64.toByteArray(value.$float);\n      if (floatBytes.byteLength !== 8) {\n        throw new Error(\n          `Received ${floatBytes.byteLength} bytes, expected 8 for $float`,\n        );\n      }\n      const floatBytesView = new DataView(floatBytes.buffer);\n      const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n      if (!isSpecial(float)) {\n        throw new Error(`Float ${float} should be encoded as a number`);\n      }\n      return float;\n    }\n    if (key === \"$set\") {\n      throw new Error(\n        `Received a Set which is no longer supported as a Convex type.`,\n      );\n    }\n    if (key === \"$map\") {\n      throw new Error(\n        `Received a Map which is no longer supported as a Convex type.`,\n      );\n    }\n  }\n  const out: { [key: string]: Value } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = jsonToConvex(v);\n  }\n  return out;\n}\n\nexport function stringifyValueForError(value: any) {\n  return JSON.stringify(value, (_key, value) => {\n    if (value === undefined) {\n      // By default `JSON.stringify` converts undefined, functions, symbols,\n      // Infinity, and NaN to null which produces a confusing error message.\n      // We deal with `undefined` specifically because it's the most common.\n      // Ideally we'd use a pretty-printing library that prints `undefined`\n      // (no quotes), but it might not be worth the bundle size cost.\n      return \"undefined\";\n    }\n    if (typeof value === \"bigint\") {\n      // `JSON.stringify` throws on bigints by default.\n      return `${value.toString()}n`;\n    }\n    return value;\n  });\n}\n\nfunction convexToJsonInternal(\n  value: Value,\n  originalValue: Value,\n  context: string,\n  includeTopLevelUndefined: boolean,\n): JSONValue {\n  if (value === undefined) {\n    const contextText =\n      context &&\n      ` (present at path ${context} in original object ${stringifyValueForError(\n        originalValue,\n      )})`;\n    throw new Error(\n      `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`,\n    );\n  }\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"bigint\") {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n      throw new Error(\n        `BigInt ${value} does not fit into a 64-bit signed integer.`,\n      );\n    }\n    return { $integer: bigIntToBase64(value) };\n  }\n  if (typeof value === \"number\") {\n    if (isSpecial(value)) {\n      const buffer = new ArrayBuffer(8);\n      new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n      return { $float: Base64.fromByteArray(new Uint8Array(buffer)) };\n    } else {\n      return value;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    return { $bytes: Base64.fromByteArray(new Uint8Array(value)) };\n  }\n  if (Array.isArray(value)) {\n    return value.map((value, i) =>\n      convexToJsonInternal(value, originalValue, context + `[${i}]`, false),\n    );\n  }\n  if (value instanceof Set) {\n    throw new Error(\n      errorMessageForUnsupportedType(context, \"Set\", [...value], originalValue),\n    );\n  }\n  if (value instanceof Map) {\n    throw new Error(\n      errorMessageForUnsupportedType(context, \"Map\", [...value], originalValue),\n    );\n  }\n\n  if (!isSimpleObject(value)) {\n    const theType = value?.constructor?.name;\n    const typeName = theType ? `${theType} ` : \"\";\n    throw new Error(\n      errorMessageForUnsupportedType(context, typeName, value, originalValue),\n    );\n  }\n\n  const out: { [key: string]: JSONValue } = {};\n  const entries = Object.entries(value);\n  entries.sort(([k1, _v1], [k2, _v2]) => (k1 === k2 ? 0 : k1 < k2 ? -1 : 1));\n  for (const [k, v] of entries) {\n    if (v !== undefined) {\n      validateObjectField(k);\n      out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`, false);\n    } else if (includeTopLevelUndefined) {\n      validateObjectField(k);\n      out[k] = convexOrUndefinedToJsonInternal(\n        v,\n        originalValue,\n        context + `.${k}`,\n      );\n    }\n  }\n  return out;\n}\n\nfunction errorMessageForUnsupportedType(\n  context: string,\n  typeName: string,\n  value: any,\n  originalValue: any,\n) {\n  if (context) {\n    return `${typeName}${stringifyValueForError(\n      value,\n    )} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n      originalValue,\n    )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`;\n  } else {\n    return `${typeName}${stringifyValueForError(\n      value,\n    )} is not a supported Convex type.`;\n  }\n}\n\n// convexOrUndefinedToJsonInternal wrapper exists so we can pipe through the\n// `originalValue` and `context` through for better error messaging.\nfunction convexOrUndefinedToJsonInternal(\n  value: Value | undefined,\n  originalValue: Value | undefined,\n  context: string,\n): JSONValue {\n  if (value === undefined) {\n    return { $undefined: null };\n  } else {\n    if (originalValue === undefined) {\n      // This should not happen.\n      throw new Error(\n        `Programming error. Current value is ${stringifyValueForError(\n          value,\n        )} but original value is undefined`,\n      );\n    }\n    return convexToJsonInternal(value, originalValue, context, false);\n  }\n}\n\n/**\n * Convert a Convex value to its JSON representation.\n *\n * Use {@link jsonToConvex} to recreate the original value.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n *\n * @public\n */\nexport function convexToJson(value: Value): JSONValue {\n  return convexToJsonInternal(value, value, \"\", false);\n}\n\n// Convert a Convex value or `undefined` into its JSON representation.\n// `undefined` is used in filters to represent a missing object field.\nexport function convexOrUndefinedToJson(value: Value | undefined): JSONValue {\n  return convexOrUndefinedToJsonInternal(value, value, \"\");\n}\n\n/**\n * Similar to convexToJson but also serializes top level undefined fields\n * using convexOrUndefinedToJson().\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n */\nexport function patchValueToJson(value: Value): JSONValue {\n  return convexToJsonInternal(value, value, \"\", true);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}