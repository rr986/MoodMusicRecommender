{"ast":null,"code":"\"use strict\";\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = Uint8Array;\nvar code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\nfunction getLens(b64) {\n  var len = b64.length;\n  if (len % 4 > 0) {\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  }\n  var validLen = b64.indexOf(\"=\");\n  if (validLen === -1) validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n}\nexport function byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction _byteLength(_b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nexport function toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0;\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 255;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  return arr;\n}\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n}\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join(\"\");\n}\nexport function fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3;\n  var parts = [];\n  var maxChunkLength = 16383;\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n  }\n  return parts.join(\"\");\n}","map":{"version":3,"names":["lookup","revLookup","Arr","Uint8Array","code","i","len","length","charCodeAt","getLens","b64","Error","validLen","indexOf","placeHoldersLen","byteLength","lens","_byteLength","_b64","toByteArray","tmp","arr","curByte","tripletToBase64","num","encodeChunk","uint8","start","end","output","push","join","fromByteArray","extraBytes","parts","maxChunkLength","len2"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/values/base64.ts"],"sourcesContent":["/* eslint-disable no-var */\n\n/*\nhttps://github.com/beatgammit/base64-js/blob/88957c9943c7e2a0f03cdf73e71d579e433627d3/index.js\nCopyright (c) 2014 Jameson Little\nThe MIT License (MIT)\n*/\n\n// Vendored because this library has no ESM build, and some environments\n// (SvelteKit) are happiest when all dependencies are ESM.\n\nvar lookup: string[] = [];\nvar revLookup: number[] = [];\nvar Arr = Uint8Array;\n\nvar code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\n\nfunction getLens(b64: string) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf(\"=\");\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen];\n}\n\n// base64 is 4/3 + up to two characters of the original data\n/** @public */\nexport function byteLength(b64: string): number {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;\n}\n\nfunction _byteLength(_b64: string, validLen: number, placeHoldersLen: number) {\n  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;\n}\n\n/** @public */\nexport function toByteArray(b64: string): Uint8Array {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xff;\n    arr[curByte++] = (tmp >> 8) & 0xff;\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xff;\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num: number) {\n  return (\n    lookup[(num >> 18) & 0x3f] +\n    lookup[(num >> 12) & 0x3f] +\n    lookup[(num >> 6) & 0x3f] +\n    lookup[num & 0x3f]\n  );\n}\n\nfunction encodeChunk(uint8: Uint8Array, start: number, end: number) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xff0000) +\n      ((uint8[i + 1] << 8) & 0xff00) +\n      (uint8[i + 2] & 0xff);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join(\"\");\n}\n\n/** @public */\nexport function fromByteArray(uint8: Uint8Array): string {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(\n      encodeChunk(\n        uint8,\n        i,\n        i + maxChunkLength > len2 ? len2 : i + maxChunkLength,\n      ),\n    );\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + \"==\");\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] +\n        lookup[(tmp >> 4) & 0x3f] +\n        lookup[(tmp << 2) & 0x3f] +\n        \"=\",\n    );\n  }\n\n  return parts.join(\"\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}