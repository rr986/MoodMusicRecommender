{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { version } from \"../../index.js\";\nimport { convexToJson } from \"../../values/index.js\";\nimport { createHybridErrorStacktrace, forwardData, logFatalError } from \"../logging.js\";\nimport { LocalSyncState } from \"./local_state.js\";\nimport { RequestManager } from \"./request_manager.js\";\nimport { OptimisticQueryResults } from \"./optimistic_updates_impl.js\";\nimport { RemoteQuerySet } from \"./remote_query_set.js\";\nimport { serializePathAndArgs } from \"./udf_path_utils.js\";\nimport { WebSocketManager } from \"./web_socket_manager.js\";\nimport { newSessionId } from \"./session.js\";\nimport { AuthenticationManager } from \"./authentication_manager.js\";\nexport {} from \"./authentication_manager.js\";\nimport { getMarksReport, mark } from \"./metrics.js\";\nimport { parseArgs, validateDeploymentUrl } from \"../../common/index.js\";\nimport { ConvexError } from \"../../values/errors.js\";\nexport class BaseConvexClient {\n  /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param onTransition - A callback receiving an array of query tokens\n   * corresponding to query results that have changed.\n   * @param options - See {@link BaseConvexClientOptions} for a full description.\n   */\n  constructor(address, onTransition, options) {\n    __publicField(this, \"address\");\n    __publicField(this, \"state\");\n    __publicField(this, \"requestManager\");\n    __publicField(this, \"webSocketManager\");\n    __publicField(this, \"authenticationManager\");\n    __publicField(this, \"remoteQuerySet\");\n    __publicField(this, \"optimisticQueryResults\");\n    __publicField(this, \"onTransition\");\n    __publicField(this, \"_nextRequestId\");\n    __publicField(this, \"_sessionId\");\n    __publicField(this, \"firstMessageReceived\", false);\n    __publicField(this, \"verbose\");\n    __publicField(this, \"debug\");\n    __publicField(this, \"maxObservedTimestamp\");\n    // Instance property so that `mark()` doesn't need to be called as a method.\n    __publicField(this, \"mark\", name => {\n      if (this.debug) {\n        mark(name, this.sessionId);\n      }\n    });\n    if (typeof address === \"object\") {\n      throw new Error(\"Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly.\");\n    }\n    if (options?.skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    options = {\n      ...options\n    };\n    let webSocketConstructor = options.webSocketConstructor;\n    if (!webSocketConstructor && typeof WebSocket === \"undefined\") {\n      throw new Error(\"No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient\");\n    }\n    webSocketConstructor = webSocketConstructor || WebSocket;\n    this.verbose = options.verbose ?? false;\n    this.debug = options.reportDebugInfoToConvex ?? false;\n    this.address = address;\n    const i = address.search(\"://\");\n    if (i === -1) {\n      throw new Error(\"Provided address was not an absolute URL.\");\n    }\n    const origin = address.substring(i + 3);\n    const protocol = address.substring(0, i);\n    let wsProtocol;\n    if (protocol === \"http\") {\n      wsProtocol = \"ws\";\n    } else if (protocol === \"https\") {\n      wsProtocol = \"wss\";\n    } else {\n      throw new Error(`Unknown parent protocol ${protocol}`);\n    }\n    const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;\n    this.state = new LocalSyncState();\n    this.remoteQuerySet = new RemoteQuerySet(queryId => this.state.queryPath(queryId));\n    this.requestManager = new RequestManager();\n    this.authenticationManager = new AuthenticationManager(this.state, {\n      authenticate: token => {\n        const message = this.state.setAuth(token);\n        this.webSocketManager.sendMessage(message);\n      },\n      stopSocket: () => this.webSocketManager.stop(),\n      restartSocket: () => this.webSocketManager.restart(),\n      pauseSocket: () => {\n        this.webSocketManager.pause();\n        this.state.pause();\n      },\n      resumeSocket: () => this.webSocketManager.resume(),\n      clearAuth: () => {\n        this.clearAuth();\n      },\n      verbose: this.verbose\n    });\n    this.optimisticQueryResults = new OptimisticQueryResults();\n    this.onTransition = onTransition;\n    this._nextRequestId = 0;\n    this._sessionId = newSessionId();\n    const {\n      unsavedChangesWarning\n    } = options;\n    if (typeof window === \"undefined\" || typeof window.addEventListener === \"undefined\") {\n      if (unsavedChangesWarning === true) {\n        throw new Error(\"unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options.\");\n      }\n    } else if (unsavedChangesWarning !== false) {\n      window.addEventListener(\"beforeunload\", e => {\n        if (this.requestManager.hasIncompleteRequests()) {\n          e.preventDefault();\n          const confirmationMessage = \"Are you sure you want to leave? Your changes may not be saved.\";\n          (e || window.event).returnValue = confirmationMessage;\n          return confirmationMessage;\n        }\n      });\n    }\n    this.webSocketManager = new WebSocketManager(wsUri, {\n      onOpen: reconnectMetadata => {\n        this.mark(\"convexWebSocketOpen\");\n        this.webSocketManager.sendMessage({\n          ...reconnectMetadata,\n          type: \"Connect\",\n          sessionId: this._sessionId,\n          maxObservedTimestamp: this.maxObservedTimestamp\n        });\n        const oldRemoteQueryResults = new Set(this.remoteQuerySet.remoteQueryResults().keys());\n        this.remoteQuerySet = new RemoteQuerySet(queryId => this.state.queryPath(queryId));\n        const [querySetModification, authModification] = this.state.restart(oldRemoteQueryResults);\n        if (authModification) {\n          this.webSocketManager.sendMessage(authModification);\n        }\n        this.webSocketManager.sendMessage(querySetModification);\n        for (const message of this.requestManager.restart()) {\n          this.webSocketManager.sendMessage(message);\n        }\n      },\n      onResume: () => {\n        const [querySetModification, authModification] = this.state.resume();\n        if (authModification) {\n          this.webSocketManager.sendMessage(authModification);\n        }\n        if (querySetModification) {\n          this.webSocketManager.sendMessage(querySetModification);\n        }\n        for (const message of this.requestManager.resume()) {\n          this.webSocketManager.sendMessage(message);\n        }\n      },\n      onMessage: serverMessage => {\n        if (!this.firstMessageReceived) {\n          this.firstMessageReceived = true;\n          this.mark(\"convexFirstMessageReceived\");\n          this.reportMarks();\n        }\n        switch (serverMessage.type) {\n          case \"Transition\":\n            {\n              this.observedTimestamp(serverMessage.endVersion.ts);\n              this.authenticationManager.onTransition(serverMessage);\n              this.remoteQuerySet.transition(serverMessage);\n              this.state.transition(serverMessage);\n              const completedRequests = this.requestManager.removeCompleted(this.remoteQuerySet.timestamp());\n              this.notifyOnQueryResultChanges(completedRequests);\n              break;\n            }\n          case \"MutationResponse\":\n            {\n              if (serverMessage.success) {\n                this.observedTimestamp(serverMessage.ts);\n              }\n              const completedMutationId = this.requestManager.onResponse(serverMessage);\n              if (completedMutationId !== null) {\n                this.notifyOnQueryResultChanges(/* @__PURE__ */new Set([completedMutationId]));\n              }\n              break;\n            }\n          case \"ActionResponse\":\n            {\n              this.requestManager.onResponse(serverMessage);\n              break;\n            }\n          case \"AuthError\":\n            {\n              this.authenticationManager.onAuthError(serverMessage);\n              break;\n            }\n          case \"FatalError\":\n            {\n              const error = logFatalError(serverMessage.error);\n              void this.webSocketManager.terminate();\n              throw error;\n            }\n          case \"Ping\":\n            break;\n          default:\n            {\n              const _typeCheck = serverMessage;\n            }\n        }\n        return {\n          hasSyncedPastLastReconnect: this.hasSyncedPastLastReconnect()\n        };\n      }\n    }, webSocketConstructor, this.verbose);\n    this.mark(\"convexClientConstructed\");\n  }\n  /**\n   * Return true if there is outstanding work from prior to the time of the most recent restart.\n   * This indicates that the client has not proven itself to have gotten past the issue that\n   * potentially led to the restart. Use this to influence when to reset backoff after a failure.\n   */\n  hasSyncedPastLastReconnect() {\n    const hasSyncedPastLastReconnect = this.requestManager.hasSyncedPastLastReconnect() || this.state.hasSyncedPastLastReconnect();\n    return hasSyncedPastLastReconnect;\n  }\n  observedTimestamp(observedTs) {\n    if (this.maxObservedTimestamp === void 0 || this.maxObservedTimestamp.lessThanOrEqual(observedTs)) {\n      this.maxObservedTimestamp = observedTs;\n    }\n  }\n  getMaxObservedTimestamp() {\n    return this.maxObservedTimestamp;\n  }\n  /**\n   * Compute the current query results based on the remoteQuerySet and the\n   * current optimistic updates and call `onTransition` for all the changed\n   * queries.\n   *\n   * @param completedMutations - A set of mutation IDs whose optimistic updates\n   * are no longer needed.\n   */\n  notifyOnQueryResultChanges(completedRequest) {\n    const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();\n    const queryTokenToValue = /* @__PURE__ */new Map();\n    for (const [queryId, result] of remoteQueryResults) {\n      const queryToken = this.state.queryToken(queryId);\n      if (queryToken !== null) {\n        const query = {\n          result,\n          udfPath: this.state.queryPath(queryId),\n          args: this.state.queryArgs(queryId)\n        };\n        queryTokenToValue.set(queryToken, query);\n      }\n    }\n    this.onTransition(this.optimisticQueryResults.ingestQueryResultsFromServer(queryTokenToValue, completedRequest));\n  }\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */\n  setAuth(fetchToken, onChange) {\n    void this.authenticationManager.setConfig(fetchToken, onChange);\n  }\n  hasAuth() {\n    return this.state.hasAuth();\n  }\n  /** @internal */\n  setAdminAuth(value, fakeUserIdentity) {\n    const message = this.state.setAdminAuth(value, fakeUserIdentity);\n    this.webSocketManager.sendMessage(message);\n  }\n  clearAuth() {\n    const message = this.state.clearAuth();\n    this.webSocketManager.sendMessage(message);\n  }\n  /**\n     * Subscribe to a query function.\n     *\n     * Whenever this query's result changes, the `onTransition` callback\n     * passed into the constructor will be called.\n     *\n     * @param name - The name of the query.\n     * @param args - An arguments object for the query. If this is omitted, the\n     * arguments will be `{}`.\n     * @param options - A {@link SubscribeOptions} options object for this query.\n  \n     * @returns An object containing a {@link QueryToken} corresponding to this\n     * query and an `unsubscribe` callback.\n     */\n  subscribe(name, args, options) {\n    const argsObject = parseArgs(args);\n    const {\n      modification,\n      queryToken,\n      unsubscribe\n    } = this.state.subscribe(name, argsObject, options?.journal, options?.componentPath);\n    if (modification !== null) {\n      this.webSocketManager.sendMessage(modification);\n    }\n    return {\n      queryToken,\n      unsubscribe: () => {\n        const modification2 = unsubscribe();\n        if (modification2) {\n          this.webSocketManager.sendMessage(modification2);\n        }\n      }\n    };\n  }\n  /**\n   * A query result based only on the current, local state.\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   */\n  localQueryResult(udfPath, args) {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(udfPath, argsObject);\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n  /**\n   * Get query result by query token based on current, local state\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   *\n   * @internal\n   */\n  localQueryResultByToken(queryToken) {\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n  /**\n   * Whether local query result is available for a toke.\n   *\n   * This method does not throw if the result is an error.\n   *\n   * @internal\n   */\n  hasLocalQueryResultByToken(queryToken) {\n    return this.optimisticQueryResults.hasQueryResult(queryToken);\n  }\n  /**\n   * @internal\n   */\n  localQueryLogs(udfPath, args) {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(udfPath, argsObject);\n    return this.optimisticQueryResults.queryLogs(queryToken);\n  }\n  /**\n   * Retrieve the current {@link QueryJournal} for this query function.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for this query.\n   * @returns The query's {@link QueryJournal} or `undefined`.\n   */\n  queryJournal(name, args) {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(name, argsObject);\n    return this.state.queryJournal(queryToken);\n  }\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState() {\n    return {\n      hasInflightRequests: this.requestManager.hasInflightRequests(),\n      isWebSocketConnected: this.webSocketManager.socketState() === \"ready\",\n      timeOfOldestInflightRequest: this.requestManager.timeOfOldestInflightRequest()\n    };\n  }\n  /**\n     * Execute a mutation function.\n     *\n     * @param name - The name of the mutation.\n     * @param args - An arguments object for the mutation. If this is omitted,\n     * the arguments will be `{}`.\n     * @param options - A {@link MutationOptions} options object for this mutation.\n  \n     * @returns - A promise of the mutation's result.\n     */\n  async mutation(name, args, options) {\n    const result = await this.mutationInternal(name, args, options);\n    if (!result.success) {\n      if (result.errorData !== void 0) {\n        throw forwardData(result, new ConvexError(createHybridErrorStacktrace(\"mutation\", name, result)));\n      }\n      throw new Error(createHybridErrorStacktrace(\"mutation\", name, result));\n    }\n    return result.value;\n  }\n  /**\n   * @internal\n   */\n  async mutationInternal(udfPath, args, options, componentPath) {\n    const mutationArgs = parseArgs(args);\n    this.tryReportLongDisconnect();\n    const requestId = this.nextRequestId;\n    this._nextRequestId++;\n    if (options !== void 0) {\n      const optimisticUpdate = options.optimisticUpdate;\n      if (optimisticUpdate !== void 0) {\n        const wrappedUpdate = localQueryStore => {\n          optimisticUpdate(localQueryStore, mutationArgs);\n        };\n        const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(wrappedUpdate, requestId);\n        this.onTransition(changedQueries);\n      }\n    }\n    const message = {\n      type: \"Mutation\",\n      requestId,\n      udfPath,\n      componentPath,\n      args: [convexToJson(mutationArgs)]\n    };\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    return this.requestManager.request(message, mightBeSent);\n  }\n  /**\n   * Execute an action function.\n   *\n   * @param name - The name of the action.\n   * @param args - An arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  async action(name, args) {\n    const result = await this.actionInternal(name, args);\n    if (!result.success) {\n      if (result.errorData !== void 0) {\n        throw forwardData(result, new ConvexError(createHybridErrorStacktrace(\"action\", name, result)));\n      }\n      throw new Error(createHybridErrorStacktrace(\"action\", name, result));\n    }\n    return result.value;\n  }\n  /**\n   * @internal\n   */\n  async actionInternal(udfPath, args, componentPath) {\n    const actionArgs = parseArgs(args);\n    const requestId = this.nextRequestId;\n    this._nextRequestId++;\n    this.tryReportLongDisconnect();\n    const message = {\n      type: \"Action\",\n      requestId,\n      udfPath,\n      componentPath,\n      args: [convexToJson(actionArgs)]\n    };\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    return this.requestManager.request(message, mightBeSent);\n  }\n  /**\n   * Close any network handles associated with this client and stop all subscriptions.\n   *\n   * Call this method when you're done with an {@link BaseConvexClient} to\n   * dispose of its sockets and resources.\n   *\n   * @returns A `Promise` fulfilled when the connection has been completely closed.\n   */\n  async close() {\n    this.authenticationManager.stop();\n    return this.webSocketManager.terminate();\n  }\n  /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */\n  get url() {\n    return this.address;\n  }\n  /**\n   * @internal\n   */\n  get nextRequestId() {\n    return this._nextRequestId;\n  }\n  /**\n   * @internal\n   */\n  get sessionId() {\n    return this._sessionId;\n  }\n  /**\n   * Reports performance marks to the server. This should only be called when\n   * we have a functional websocket.\n   */\n  reportMarks() {\n    if (this.debug) {\n      const report = getMarksReport(this.sessionId);\n      this.webSocketManager.sendMessage({\n        type: \"Event\",\n        eventType: \"ClientConnect\",\n        event: report\n      });\n    }\n  }\n  tryReportLongDisconnect() {\n    if (!this.debug) {\n      return;\n    }\n    const timeOfOldestRequest = this.connectionState().timeOfOldestInflightRequest;\n    if (timeOfOldestRequest === null || Date.now() - timeOfOldestRequest.getTime() <= 60 * 1e3) {\n      return;\n    }\n    const endpoint = `${this.address}/api/debug_event`;\n    fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`\n      },\n      body: JSON.stringify({\n        event: \"LongWebsocketDisconnect\"\n      })\n    }).then(response => {\n      if (!response.ok) {\n        console.warn(\"Analytics request failed with response:\", response.body);\n      }\n    }).catch(error => {\n      console.warn(\"Analytics response failed with error:\", error);\n    });\n  }\n}","map":{"version":3,"names":["version","convexToJson","createHybridErrorStacktrace","forwardData","logFatalError","LocalSyncState","RequestManager","OptimisticQueryResults","RemoteQuerySet","serializePathAndArgs","WebSocketManager","newSessionId","AuthenticationManager","getMarksReport","mark","parseArgs","validateDeploymentUrl","ConvexError","BaseConvexClient","constructor","address","onTransition","options","__publicField","name","debug","sessionId","Error","skipConvexDeploymentUrlCheck","webSocketConstructor","WebSocket","verbose","reportDebugInfoToConvex","i","search","origin","substring","protocol","wsProtocol","wsUri","state","remoteQuerySet","queryId","queryPath","requestManager","authenticationManager","authenticate","token","message","setAuth","webSocketManager","sendMessage","stopSocket","stop","restartSocket","restart","pauseSocket","pause","resumeSocket","resume","clearAuth","optimisticQueryResults","_nextRequestId","_sessionId","unsavedChangesWarning","window","addEventListener","e","hasIncompleteRequests","preventDefault","confirmationMessage","event","returnValue","onOpen","reconnectMetadata","type","maxObservedTimestamp","oldRemoteQueryResults","Set","remoteQueryResults","keys","querySetModification","authModification","onResume","onMessage","serverMessage","firstMessageReceived","reportMarks","observedTimestamp","endVersion","ts","transition","completedRequests","removeCompleted","timestamp","notifyOnQueryResultChanges","success","completedMutationId","onResponse","onAuthError","error","terminate","_typeCheck","hasSyncedPastLastReconnect","observedTs","lessThanOrEqual","getMaxObservedTimestamp","completedRequest","queryTokenToValue","Map","result","queryToken","query","udfPath","args","queryArgs","set","ingestQueryResultsFromServer","fetchToken","onChange","setConfig","hasAuth","setAdminAuth","value","fakeUserIdentity","subscribe","argsObject","modification","unsubscribe","journal","componentPath","modification2","localQueryResult","queryResult","localQueryResultByToken","hasLocalQueryResultByToken","hasQueryResult","localQueryLogs","queryLogs","queryJournal","connectionState","hasInflightRequests","isWebSocketConnected","socketState","timeOfOldestInflightRequest","mutation","mutationInternal","errorData","mutationArgs","tryReportLongDisconnect","requestId","nextRequestId","optimisticUpdate","wrappedUpdate","localQueryStore","changedQueries","applyOptimisticUpdate","mightBeSent","request","action","actionInternal","actionArgs","close","url","report","eventType","timeOfOldestRequest","Date","now","getTime","endpoint","fetch","method","headers","body","JSON","stringify","then","response","ok","console","warn","catch"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/browser/sync/client.ts"],"sourcesContent":["import { version } from \"../../index.js\";\nimport { convexToJson, Value } from \"../../values/index.js\";\nimport {\n  createHybridErrorStacktrace,\n  forwardData,\n  logFatalError,\n} from \"../logging.js\";\nimport { LocalSyncState } from \"./local_state.js\";\nimport { RequestManager } from \"./request_manager.js\";\nimport {\n  OptimisticLocalStore,\n  OptimisticUpdate,\n} from \"./optimistic_updates.js\";\nimport {\n  OptimisticQueryResults,\n  QueryResultsMap,\n} from \"./optimistic_updates_impl.js\";\nimport {\n  ActionRequest,\n  MutationRequest,\n  QueryId,\n  QueryJournal,\n  RequestId,\n  ServerMessage,\n  TS,\n  UserIdentityAttributes,\n} from \"./protocol.js\";\nimport { RemoteQuerySet } from \"./remote_query_set.js\";\nimport { QueryToken, serializePathAndArgs } from \"./udf_path_utils.js\";\nimport { ReconnectMetadata, WebSocketManager } from \"./web_socket_manager.js\";\nimport { newSessionId } from \"./session.js\";\nimport { FunctionResult } from \"./function_result.js\";\nimport {\n  AuthenticationManager,\n  AuthTokenFetcher,\n} from \"./authentication_manager.js\";\nexport { type AuthTokenFetcher } from \"./authentication_manager.js\";\nimport { getMarksReport, mark, MarkName } from \"./metrics.js\";\nimport { parseArgs, validateDeploymentUrl } from \"../../common/index.js\";\nimport { ConvexError } from \"../../values/errors.js\";\n\n/**\n * Options for {@link BaseConvexClient}.\n *\n * @public\n */\nexport interface BaseConvexClientOptions {\n  /**\n   * Whether to prompt the user if they have unsaved changes pending\n   * when navigating away or closing a web page.\n   *\n   * This is only possible when the `window` object exists, i.e. in a browser.\n   *\n   * The default value is `true` in browsers.\n   */\n  unsavedChangesWarning?: boolean;\n  /**\n   * Specifies an alternate\n   * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n   * constructor to use for client communication with the Convex cloud.\n   * The default behavior is to use `WebSocket` from the global environment.\n   */\n  webSocketConstructor?: typeof WebSocket;\n  /**\n   * Adds additional logging for debugging purposes.\n   *\n   * The default value is `false`.\n   */\n  verbose?: boolean;\n  /**\n   * Sends additional metrics to Convex for debugging purposes.\n   *\n   * The default value is `false`.\n   */\n  reportDebugInfoToConvex?: boolean;\n  /**\n   * Skip validating that the Convex deployment URL looks like\n   * `https://happy-animal-123.convex.cloud` or localhost.\n   *\n   * This can be useful if running a self-hosted Convex backend that uses a different\n   * URL.\n   *\n   * The default value is `false`\n   */\n  skipConvexDeploymentUrlCheck?: boolean;\n}\n\n/**\n * State describing the client's connection with the Convex backend.\n *\n * @public\n */\nexport type ConnectionState = {\n  hasInflightRequests: boolean;\n  isWebSocketConnected: boolean;\n  timeOfOldestInflightRequest: Date | null;\n};\n\n/**\n * Options for {@link BaseConvexClient.subscribe}.\n *\n * @public\n */\nexport interface SubscribeOptions {\n  /**\n   * An (optional) journal produced from a previous execution of this query\n   * function.\n   *\n   * If there is an existing subscription to a query function with the same\n   * name and arguments, this journal will have no effect.\n   */\n  journal?: QueryJournal;\n\n  /**\n   * @internal\n   */\n  componentPath?: string;\n}\n\n/**\n * Options for {@link BaseConvexClient.mutation}.\n *\n * @public\n */\nexport interface MutationOptions {\n  /**\n   * An optimistic update to apply along with this mutation.\n   *\n   * An optimistic update locally updates queries while a mutation is pending.\n   * Once the mutation completes, the update will be rolled back.\n   */\n  optimisticUpdate?: OptimisticUpdate<any>;\n}\n\n/**\n * Low-level client for directly integrating state management libraries\n * with Convex.\n *\n * Most developers should use higher level clients, like\n * the {@link ConvexHttpClient} or the React hook based {@link react.ConvexReactClient}.\n *\n * @public\n */\nexport class BaseConvexClient {\n  private readonly address: string;\n  private readonly state: LocalSyncState;\n  private readonly requestManager: RequestManager;\n  private readonly webSocketManager: WebSocketManager;\n  private readonly authenticationManager: AuthenticationManager;\n  private remoteQuerySet: RemoteQuerySet;\n  private readonly optimisticQueryResults: OptimisticQueryResults;\n  private readonly onTransition: (updatedQueries: QueryToken[]) => void;\n  private _nextRequestId: RequestId;\n  private readonly _sessionId: string;\n  private firstMessageReceived = false;\n  private readonly verbose: boolean;\n  private readonly debug: boolean;\n  private maxObservedTimestamp: TS | undefined;\n\n  /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param onTransition - A callback receiving an array of query tokens\n   * corresponding to query results that have changed.\n   * @param options - See {@link BaseConvexClientOptions} for a full description.\n   */\n  constructor(\n    address: string,\n    onTransition: (updatedQueries: QueryToken[]) => void,\n    options?: BaseConvexClientOptions,\n  ) {\n    if (typeof address === \"object\") {\n      throw new Error(\n        \"Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly.\",\n      );\n    }\n    if (options?.skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    options = { ...options };\n    let webSocketConstructor = options.webSocketConstructor;\n    if (!webSocketConstructor && typeof WebSocket === \"undefined\") {\n      throw new Error(\n        \"No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient\",\n      );\n    }\n    webSocketConstructor = webSocketConstructor || WebSocket;\n    this.verbose = options.verbose ?? false;\n    this.debug = options.reportDebugInfoToConvex ?? false;\n    this.address = address;\n\n    // Substitute http(s) with ws(s)\n    const i = address.search(\"://\");\n    if (i === -1) {\n      throw new Error(\"Provided address was not an absolute URL.\");\n    }\n    const origin = address.substring(i + 3); // move past the double slash\n    const protocol = address.substring(0, i);\n    let wsProtocol;\n    if (protocol === \"http\") {\n      wsProtocol = \"ws\";\n    } else if (protocol === \"https\") {\n      wsProtocol = \"wss\";\n    } else {\n      throw new Error(`Unknown parent protocol ${protocol}`);\n    }\n    const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;\n\n    this.state = new LocalSyncState();\n    this.remoteQuerySet = new RemoteQuerySet((queryId) =>\n      this.state.queryPath(queryId),\n    );\n    this.requestManager = new RequestManager();\n    this.authenticationManager = new AuthenticationManager(this.state, {\n      authenticate: (token) => {\n        const message = this.state.setAuth(token);\n        this.webSocketManager.sendMessage(message);\n      },\n      stopSocket: () => this.webSocketManager.stop(),\n      restartSocket: () => this.webSocketManager.restart(),\n      pauseSocket: () => {\n        this.webSocketManager.pause();\n        this.state.pause();\n      },\n      resumeSocket: () => this.webSocketManager.resume(),\n      clearAuth: () => {\n        this.clearAuth();\n      },\n      verbose: this.verbose,\n    });\n    this.optimisticQueryResults = new OptimisticQueryResults();\n    this.onTransition = onTransition;\n    this._nextRequestId = 0;\n    this._sessionId = newSessionId();\n\n    const { unsavedChangesWarning } = options;\n    if (\n      typeof window === \"undefined\" ||\n      typeof window.addEventListener === \"undefined\"\n    ) {\n      if (unsavedChangesWarning === true) {\n        throw new Error(\n          \"unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options.\",\n        );\n      }\n    } else if (unsavedChangesWarning !== false) {\n      // Listen for tab close events and notify the user on unsaved changes.\n      window.addEventListener(\"beforeunload\", (e) => {\n        if (this.requestManager.hasIncompleteRequests()) {\n          // There are 3 different ways to trigger this pop up so just try all of\n          // them.\n\n          e.preventDefault();\n          // This confirmation message doesn't actually appear in most modern\n          // browsers but we tried.\n          const confirmationMessage =\n            \"Are you sure you want to leave? Your changes may not be saved.\";\n          (e || window.event).returnValue = confirmationMessage;\n          return confirmationMessage;\n        }\n      });\n    }\n\n    this.webSocketManager = new WebSocketManager(\n      wsUri,\n      {\n        onOpen: (reconnectMetadata: ReconnectMetadata) => {\n          // We have a new WebSocket!\n          this.mark(\"convexWebSocketOpen\");\n          this.webSocketManager.sendMessage({\n            ...reconnectMetadata,\n            type: \"Connect\",\n            sessionId: this._sessionId,\n            maxObservedTimestamp: this.maxObservedTimestamp,\n          });\n\n          // Throw out our remote query, reissue queries\n          // and outstanding mutations, and reauthenticate.\n          const oldRemoteQueryResults = new Set(\n            this.remoteQuerySet.remoteQueryResults().keys(),\n          );\n          this.remoteQuerySet = new RemoteQuerySet((queryId) =>\n            this.state.queryPath(queryId),\n          );\n          const [querySetModification, authModification] = this.state.restart(\n            oldRemoteQueryResults,\n          );\n          if (authModification) {\n            this.webSocketManager.sendMessage(authModification);\n          }\n          this.webSocketManager.sendMessage(querySetModification);\n          for (const message of this.requestManager.restart()) {\n            this.webSocketManager.sendMessage(message);\n          }\n        },\n        onResume: () => {\n          const [querySetModification, authModification] = this.state.resume();\n          if (authModification) {\n            this.webSocketManager.sendMessage(authModification);\n          }\n          if (querySetModification) {\n            this.webSocketManager.sendMessage(querySetModification);\n          }\n          for (const message of this.requestManager.resume()) {\n            this.webSocketManager.sendMessage(message);\n          }\n        },\n        onMessage: (serverMessage: ServerMessage) => {\n          // Metrics events grow linearly with reconnection attempts so this\n          // conditional prevents n^2 metrics reporting.\n          if (!this.firstMessageReceived) {\n            this.firstMessageReceived = true;\n            this.mark(\"convexFirstMessageReceived\");\n            this.reportMarks();\n          }\n          switch (serverMessage.type) {\n            case \"Transition\": {\n              this.observedTimestamp(serverMessage.endVersion.ts);\n              this.authenticationManager.onTransition(serverMessage);\n              this.remoteQuerySet.transition(serverMessage);\n              this.state.transition(serverMessage);\n              const completedRequests = this.requestManager.removeCompleted(\n                this.remoteQuerySet.timestamp(),\n              );\n              this.notifyOnQueryResultChanges(completedRequests);\n              break;\n            }\n            case \"MutationResponse\": {\n              if (serverMessage.success) {\n                this.observedTimestamp(serverMessage.ts);\n              }\n              const completedMutationId =\n                this.requestManager.onResponse(serverMessage);\n              if (completedMutationId !== null) {\n                this.notifyOnQueryResultChanges(new Set([completedMutationId]));\n              }\n              break;\n            }\n            case \"ActionResponse\": {\n              this.requestManager.onResponse(serverMessage);\n              break;\n            }\n            case \"AuthError\": {\n              this.authenticationManager.onAuthError(serverMessage);\n              break;\n            }\n            case \"FatalError\": {\n              const error = logFatalError(serverMessage.error);\n              void this.webSocketManager.terminate();\n              throw error;\n            }\n            case \"Ping\":\n              break; // do nothing\n            default: {\n              const _typeCheck: never = serverMessage;\n            }\n          }\n\n          return {\n            hasSyncedPastLastReconnect: this.hasSyncedPastLastReconnect(),\n          };\n        },\n      },\n      webSocketConstructor,\n      this.verbose,\n    );\n    this.mark(\"convexClientConstructed\");\n  }\n\n  /**\n   * Return true if there is outstanding work from prior to the time of the most recent restart.\n   * This indicates that the client has not proven itself to have gotten past the issue that\n   * potentially led to the restart. Use this to influence when to reset backoff after a failure.\n   */\n  private hasSyncedPastLastReconnect() {\n    const hasSyncedPastLastReconnect =\n      this.requestManager.hasSyncedPastLastReconnect() ||\n      this.state.hasSyncedPastLastReconnect();\n    return hasSyncedPastLastReconnect;\n  }\n\n  private observedTimestamp(observedTs: TS) {\n    if (\n      this.maxObservedTimestamp === undefined ||\n      this.maxObservedTimestamp.lessThanOrEqual(observedTs)\n    ) {\n      this.maxObservedTimestamp = observedTs;\n    }\n  }\n\n  getMaxObservedTimestamp() {\n    return this.maxObservedTimestamp;\n  }\n\n  /**\n   * Compute the current query results based on the remoteQuerySet and the\n   * current optimistic updates and call `onTransition` for all the changed\n   * queries.\n   *\n   * @param completedMutations - A set of mutation IDs whose optimistic updates\n   * are no longer needed.\n   */\n  private notifyOnQueryResultChanges(completedRequest: Set<RequestId>) {\n    const remoteQueryResults: Map<QueryId, FunctionResult> =\n      this.remoteQuerySet.remoteQueryResults();\n    const queryTokenToValue: QueryResultsMap = new Map();\n    for (const [queryId, result] of remoteQueryResults) {\n      const queryToken = this.state.queryToken(queryId);\n      // It's possible that we've already unsubscribed to this query but\n      // the server hasn't learned about that yet. If so, ignore this one.\n\n      if (queryToken !== null) {\n        const query = {\n          result,\n          udfPath: this.state.queryPath(queryId)!,\n          args: this.state.queryArgs(queryId)!,\n        };\n        queryTokenToValue.set(queryToken, query);\n      }\n    }\n\n    this.onTransition(\n      this.optimisticQueryResults.ingestQueryResultsFromServer(\n        queryTokenToValue,\n        completedRequest,\n      ),\n    );\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */\n  setAuth(\n    fetchToken: AuthTokenFetcher,\n    onChange: (isAuthenticated: boolean) => void,\n  ) {\n    void this.authenticationManager.setConfig(fetchToken, onChange);\n  }\n\n  hasAuth() {\n    return this.state.hasAuth();\n  }\n\n  /** @internal */\n  setAdminAuth(value: string, fakeUserIdentity?: UserIdentityAttributes) {\n    const message = this.state.setAdminAuth(value, fakeUserIdentity);\n    this.webSocketManager.sendMessage(message);\n  }\n\n  clearAuth() {\n    const message = this.state.clearAuth();\n    this.webSocketManager.sendMessage(message);\n  }\n\n  /**\n   * Subscribe to a query function.\n   *\n   * Whenever this query's result changes, the `onTransition` callback\n   * passed into the constructor will be called.\n   *\n   * @param name - The name of the query.\n   * @param args - An arguments object for the query. If this is omitted, the\n   * arguments will be `{}`.\n   * @param options - A {@link SubscribeOptions} options object for this query.\n\n   * @returns An object containing a {@link QueryToken} corresponding to this\n   * query and an `unsubscribe` callback.\n   */\n  subscribe(\n    name: string,\n    args?: Record<string, Value>,\n    options?: SubscribeOptions,\n  ): { queryToken: QueryToken; unsubscribe: () => void } {\n    const argsObject = parseArgs(args);\n\n    const { modification, queryToken, unsubscribe } = this.state.subscribe(\n      name,\n      argsObject,\n      options?.journal,\n      options?.componentPath,\n    );\n    if (modification !== null) {\n      this.webSocketManager.sendMessage(modification);\n    }\n    return {\n      queryToken,\n      unsubscribe: () => {\n        const modification = unsubscribe();\n        if (modification) {\n          this.webSocketManager.sendMessage(modification);\n        }\n      },\n    };\n  }\n\n  /**\n   * A query result based only on the current, local state.\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   */\n  localQueryResult(\n    udfPath: string,\n    args?: Record<string, Value>,\n  ): Value | undefined {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(udfPath, argsObject);\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n\n  /**\n   * Get query result by query token based on current, local state\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   *\n   * @internal\n   */\n  localQueryResultByToken(queryToken: QueryToken): Value | undefined {\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n\n  /**\n   * Whether local query result is available for a toke.\n   *\n   * This method does not throw if the result is an error.\n   *\n   * @internal\n   */\n  hasLocalQueryResultByToken(queryToken: QueryToken): boolean {\n    return this.optimisticQueryResults.hasQueryResult(queryToken);\n  }\n\n  /**\n   * @internal\n   */\n  localQueryLogs(\n    udfPath: string,\n    args?: Record<string, Value>,\n  ): string[] | undefined {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(udfPath, argsObject);\n    return this.optimisticQueryResults.queryLogs(queryToken);\n  }\n\n  /**\n   * Retrieve the current {@link QueryJournal} for this query function.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for this query.\n   * @returns The query's {@link QueryJournal} or `undefined`.\n   */\n  queryJournal(\n    name: string,\n    args?: Record<string, Value>,\n  ): QueryJournal | undefined {\n    const argsObject = parseArgs(args);\n    const queryToken = serializePathAndArgs(name, argsObject);\n    return this.state.queryJournal(queryToken);\n  }\n\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState(): ConnectionState {\n    return {\n      hasInflightRequests: this.requestManager.hasInflightRequests(),\n      isWebSocketConnected: this.webSocketManager.socketState() === \"ready\",\n      timeOfOldestInflightRequest:\n        this.requestManager.timeOfOldestInflightRequest(),\n    };\n  }\n\n  /**\n   * Execute a mutation function.\n   *\n   * @param name - The name of the mutation.\n   * @param args - An arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - A {@link MutationOptions} options object for this mutation.\n\n   * @returns - A promise of the mutation's result.\n   */\n  async mutation(\n    name: string,\n    args?: Record<string, Value>,\n    options?: MutationOptions,\n  ): Promise<any> {\n    const result = await this.mutationInternal(name, args, options);\n    if (!result.success) {\n      if (result.errorData !== undefined) {\n        throw forwardData(\n          result,\n          new ConvexError(\n            createHybridErrorStacktrace(\"mutation\", name, result),\n          ),\n        );\n      }\n      throw new Error(createHybridErrorStacktrace(\"mutation\", name, result));\n    }\n    return result.value;\n  }\n\n  /**\n   * @internal\n   */\n  async mutationInternal(\n    udfPath: string,\n    args?: Record<string, Value>,\n    options?: MutationOptions,\n    componentPath?: string,\n  ): Promise<FunctionResult> {\n    const mutationArgs = parseArgs(args);\n    this.tryReportLongDisconnect();\n    const requestId = this.nextRequestId;\n    this._nextRequestId++;\n\n    if (options !== undefined) {\n      const optimisticUpdate = options.optimisticUpdate;\n      if (optimisticUpdate !== undefined) {\n        const wrappedUpdate = (localQueryStore: OptimisticLocalStore) => {\n          optimisticUpdate(localQueryStore, mutationArgs);\n        };\n\n        const changedQueries =\n          this.optimisticQueryResults.applyOptimisticUpdate(\n            wrappedUpdate,\n            requestId,\n          );\n        this.onTransition(changedQueries);\n      }\n    }\n\n    const message: MutationRequest = {\n      type: \"Mutation\",\n      requestId,\n      udfPath,\n      componentPath,\n      args: [convexToJson(mutationArgs)],\n    };\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    return this.requestManager.request(message, mightBeSent);\n  }\n\n  /**\n   * Execute an action function.\n   *\n   * @param name - The name of the action.\n   * @param args - An arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  async action(name: string, args?: Record<string, Value>): Promise<any> {\n    const result = await this.actionInternal(name, args);\n    if (!result.success) {\n      if (result.errorData !== undefined) {\n        throw forwardData(\n          result,\n          new ConvexError(createHybridErrorStacktrace(\"action\", name, result)),\n        );\n      }\n      throw new Error(createHybridErrorStacktrace(\"action\", name, result));\n    }\n    return result.value;\n  }\n\n  /**\n   * @internal\n   */\n  async actionInternal(\n    udfPath: string,\n    args?: Record<string, Value>,\n    componentPath?: string,\n  ): Promise<FunctionResult> {\n    const actionArgs = parseArgs(args);\n    const requestId = this.nextRequestId;\n    this._nextRequestId++;\n    this.tryReportLongDisconnect();\n\n    const message: ActionRequest = {\n      type: \"Action\",\n      requestId,\n      udfPath,\n      componentPath,\n      args: [convexToJson(actionArgs)],\n    };\n\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    return this.requestManager.request(message, mightBeSent);\n  }\n\n  /**\n   * Close any network handles associated with this client and stop all subscriptions.\n   *\n   * Call this method when you're done with an {@link BaseConvexClient} to\n   * dispose of its sockets and resources.\n   *\n   * @returns A `Promise` fulfilled when the connection has been completely closed.\n   */\n  async close(): Promise<void> {\n    this.authenticationManager.stop();\n    return this.webSocketManager.terminate();\n  }\n\n  /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */\n  get url() {\n    return this.address;\n  }\n\n  /**\n   * @internal\n   */\n  get nextRequestId() {\n    return this._nextRequestId;\n  }\n\n  /**\n   * @internal\n   */\n  get sessionId() {\n    return this._sessionId;\n  }\n\n  // Instance property so that `mark()` doesn't need to be called as a method.\n  private mark = (name: MarkName) => {\n    if (this.debug) {\n      mark(name, this.sessionId);\n    }\n  };\n\n  /**\n   * Reports performance marks to the server. This should only be called when\n   * we have a functional websocket.\n   */\n  private reportMarks() {\n    if (this.debug) {\n      const report = getMarksReport(this.sessionId);\n      this.webSocketManager.sendMessage({\n        type: \"Event\",\n        eventType: \"ClientConnect\",\n        event: report,\n      });\n    }\n  }\n\n  private tryReportLongDisconnect() {\n    if (!this.debug) {\n      return;\n    }\n    const timeOfOldestRequest =\n      this.connectionState().timeOfOldestInflightRequest;\n    if (\n      timeOfOldestRequest === null ||\n      Date.now() - timeOfOldestRequest.getTime() <= 60 * 1000\n    ) {\n      return;\n    }\n    const endpoint = `${this.address}/api/debug_event`;\n    fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      },\n      body: JSON.stringify({ event: \"LongWebsocketDisconnect\" }),\n    })\n      .then((response) => {\n        if (!response.ok) {\n          console.warn(\n            \"Analytics request failed with response:\",\n            response.body,\n          );\n        }\n      })\n      .catch((error) => {\n        console.warn(\"Analytics response failed with error:\", error);\n      });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}