{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { encodeClientMessage, parseServerMessage } from \"./protocol.js\";\nconst CLOSE_NORMAL = 1e3;\nconst CLOSE_GOING_AWAY = 1001;\nconst CLOSE_NO_STATUS = 1005;\nconst CLOSE_NOT_FOUND = 4040;\nexport class WebSocketManager {\n  constructor(uri, callbacks, webSocketConstructor, verbose) {\n    __publicField(this, \"socket\");\n    __publicField(this, \"connectionCount\");\n    __publicField(this, \"lastCloseReason\");\n    /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */\n    __publicField(this, \"initialBackoff\");\n    /** We backoff exponentially, but we need to cap that--this is the jittered max. */\n    __publicField(this, \"maxBackoff\");\n    /** How many times have we failed consecutively? */\n    __publicField(this, \"retries\");\n    /** How long before lack of server response causes us to initiate a reconnect,\n     * in ms */\n    __publicField(this, \"serverInactivityThreshold\");\n    __publicField(this, \"reconnectDueToServerInactivityTimeout\");\n    __publicField(this, \"uri\");\n    __publicField(this, \"onOpen\");\n    __publicField(this, \"onResume\");\n    __publicField(this, \"onMessage\");\n    __publicField(this, \"webSocketConstructor\");\n    __publicField(this, \"verbose\");\n    this.webSocketConstructor = webSocketConstructor;\n    this.socket = {\n      state: \"disconnected\"\n    };\n    this.connectionCount = 0;\n    this.lastCloseReason = \"InitialConnect\";\n    this.initialBackoff = 100;\n    this.maxBackoff = 16e3;\n    this.retries = 0;\n    this.serverInactivityThreshold = 3e4;\n    this.reconnectDueToServerInactivityTimeout = null;\n    this.uri = uri;\n    this.onOpen = callbacks.onOpen;\n    this.onResume = callbacks.onResume;\n    this.onMessage = callbacks.onMessage;\n    this.verbose = verbose;\n    this.connect();\n  }\n  connect() {\n    if (this.socket.state === \"terminated\") {\n      return;\n    }\n    if (this.socket.state !== \"disconnected\" && this.socket.state !== \"stopped\") {\n      throw new Error(\"Didn't start connection from disconnected state: \" + this.socket.state);\n    }\n    const ws = new this.webSocketConstructor(this.uri);\n    this._logVerbose(\"constructed WebSocket\");\n    this.socket = {\n      state: \"connecting\",\n      ws,\n      paused: \"no\"\n    };\n    this.resetServerInactivityTimeout();\n    ws.onopen = () => {\n      this._logVerbose(\"begin ws.onopen\");\n      if (this.socket.state !== \"connecting\") {\n        throw new Error(\"onopen called with socket not in connecting state\");\n      }\n      this.socket = {\n        state: \"ready\",\n        ws,\n        paused: this.socket.paused === \"yes\" ? \"uninitialized\" : \"no\"\n      };\n      this.resetServerInactivityTimeout();\n      if (this.socket.paused === \"no\") {\n        this.onOpen({\n          connectionCount: this.connectionCount,\n          lastCloseReason: this.lastCloseReason\n        });\n      }\n      if (this.lastCloseReason !== \"InitialConnect\") {\n        console.log(\"WebSocket reconnected\");\n      }\n      this.connectionCount += 1;\n      this.lastCloseReason = null;\n    };\n    ws.onerror = error => {\n      const message = error.message;\n      console.log(`WebSocket error: ${message}`);\n    };\n    ws.onmessage = message => {\n      this.resetServerInactivityTimeout();\n      const serverMessage = parseServerMessage(JSON.parse(message.data));\n      this._logVerbose(`received ws message with type ${serverMessage.type}`);\n      const response = this.onMessage(serverMessage);\n      if (response.hasSyncedPastLastReconnect) {\n        this.retries = 0;\n      }\n    };\n    ws.onclose = event => {\n      this._logVerbose(\"begin ws.onclose\");\n      if (this.lastCloseReason === null) {\n        this.lastCloseReason = event.reason ?? \"OnCloseInvoked\";\n      }\n      if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_GOING_AWAY &&\n      // This commonly gets fired on mobile apps when the app is backgrounded\n      event.code !== CLOSE_NO_STATUS && event.code !== CLOSE_NOT_FOUND) {\n        let msg = `WebSocket closed with code ${event.code}`;\n        if (event.reason) {\n          msg += `: ${event.reason}`;\n        }\n        console.log(msg);\n      }\n      this.scheduleReconnect();\n      return;\n    };\n  }\n  /**\n   * @returns The state of the {@link Socket}.\n   */\n  socketState() {\n    return this.socket.state;\n  }\n  /**\n   * @param message - A ClientMessage to send.\n   * @returns Whether the message (might have been) sent.\n   */\n  sendMessage(message) {\n    this._logVerbose(`sending message with type ${message.type}`);\n    if (this.socket.state === \"ready\" && this.socket.paused === \"no\") {\n      const encodedMessage = encodeClientMessage(message);\n      const request = JSON.stringify(encodedMessage);\n      try {\n        this.socket.ws.send(request);\n      } catch (error) {\n        console.log(`Failed to send message on WebSocket, reconnecting: ${error}`);\n        this.closeAndReconnect(\"FailedToSendMessage\");\n      }\n      return true;\n    }\n    return false;\n  }\n  resetServerInactivityTimeout() {\n    if (this.socket.state === \"terminated\") {\n      return;\n    }\n    if (this.reconnectDueToServerInactivityTimeout !== null) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n      this.reconnectDueToServerInactivityTimeout = null;\n    }\n    this.reconnectDueToServerInactivityTimeout = setTimeout(() => {\n      this.closeAndReconnect(\"InactiveServer\");\n    }, this.serverInactivityThreshold);\n  }\n  scheduleReconnect() {\n    this.socket = {\n      state: \"disconnected\"\n    };\n    const backoff = this.nextBackoff();\n    console.log(`Attempting reconnect in ${backoff}ms`);\n    setTimeout(() => this.connect(), backoff);\n  }\n  /**\n   * Close the WebSocket and schedule a reconnect.\n   *\n   * This should be used when we hit an error and would like to restart the session.\n   */\n  closeAndReconnect(closeReason) {\n    this._logVerbose(`begin closeAndReconnect with reason ${closeReason}`);\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"terminated\":\n      case \"stopped\":\n        return;\n      case \"connecting\":\n      case \"ready\":\n        {\n          this.lastCloseReason = closeReason;\n          void this.close();\n          this.scheduleReconnect();\n          return;\n        }\n      default:\n        {\n          const _ = this.socket;\n        }\n    }\n  }\n  /**\n   * Close the WebSocket, being careful to clear the onclose handler to avoid re-entrant\n   * calls. Use this instead of directly calling `ws.close()`\n   *\n   * It is the callers responsibility to update the state after this method is called so that the\n   * closed socket is not accessible or used again after this method is called\n   */\n  close() {\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"terminated\":\n      case \"stopped\":\n        return Promise.resolve();\n      case \"connecting\":\n        {\n          const ws = this.socket.ws;\n          return new Promise(r => {\n            ws.onclose = () => {\n              this._logVerbose(\"Closed after connecting\");\n              r();\n            };\n            ws.onopen = () => {\n              this._logVerbose(\"Opened after connecting\");\n              ws.close();\n            };\n          });\n        }\n      case \"ready\":\n        {\n          this._logVerbose(\"ws.close called\");\n          const ws = this.socket.ws;\n          const result = new Promise(r => {\n            ws.onclose = () => {\n              r();\n            };\n          });\n          ws.close();\n          return result;\n        }\n      default:\n        {\n          const _ = this.socket;\n          return Promise.resolve();\n        }\n    }\n  }\n  /**\n   * Close the WebSocket and do not reconnect.\n   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.\n   */\n  terminate() {\n    if (this.reconnectDueToServerInactivityTimeout) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n    }\n    switch (this.socket.state) {\n      case \"terminated\":\n      case \"stopped\":\n      case \"disconnected\":\n      case \"connecting\":\n      case \"ready\":\n        {\n          const result = this.close();\n          this.socket = {\n            state: \"terminated\"\n          };\n          return result;\n        }\n      default:\n        {\n          const _ = this.socket;\n          throw new Error(`Invalid websocket state: ${this.socket.state}`);\n        }\n    }\n  }\n  stop() {\n    switch (this.socket.state) {\n      case \"terminated\":\n        return Promise.resolve();\n      case \"connecting\":\n      case \"stopped\":\n      case \"disconnected\":\n      case \"ready\":\n        {\n          const result = this.close();\n          this.socket = {\n            state: \"stopped\"\n          };\n          return result;\n        }\n      default:\n        {\n          const _ = this.socket;\n          return Promise.resolve();\n        }\n    }\n  }\n  /**\n   * Create a new WebSocket after a previous `stop()`, unless `terminate()` was\n   * called before.\n   */\n  restart() {\n    switch (this.socket.state) {\n      case \"stopped\":\n        break;\n      case \"terminated\":\n        return;\n      case \"connecting\":\n      case \"ready\":\n      case \"disconnected\":\n        throw new Error(\"`restart()` is only valid after `stop()`\");\n      default:\n        {\n          const _ = this.socket;\n        }\n    }\n    this.connect();\n  }\n  pause() {\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"stopped\":\n      case \"terminated\":\n        return;\n      case \"connecting\":\n      case \"ready\":\n        {\n          this.socket = {\n            ...this.socket,\n            paused: \"yes\"\n          };\n          return;\n        }\n      default:\n        {\n          const _ = this.socket;\n          return;\n        }\n    }\n  }\n  /**\n   * Resume the state machine if previously paused.\n   */\n  resume() {\n    switch (this.socket.state) {\n      case \"connecting\":\n        this.socket = {\n          ...this.socket,\n          paused: \"no\"\n        };\n        return;\n      case \"ready\":\n        if (this.socket.paused === \"uninitialized\") {\n          this.socket = {\n            ...this.socket,\n            paused: \"no\"\n          };\n          this.onOpen({\n            connectionCount: this.connectionCount,\n            lastCloseReason: this.lastCloseReason\n          });\n        } else if (this.socket.paused === \"yes\") {\n          this.socket = {\n            ...this.socket,\n            paused: \"no\"\n          };\n          this.onResume();\n        }\n        return;\n      case \"terminated\":\n      case \"stopped\":\n      case \"disconnected\":\n        return;\n      default:\n        {\n          const _ = this.socket;\n        }\n    }\n    this.connect();\n  }\n  _logVerbose(message) {\n    if (this.verbose) {\n      console.debug(`${(/* @__PURE__ */new Date()).toISOString()} ${message}`);\n    }\n  }\n  nextBackoff() {\n    const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);\n    this.retries += 1;\n    const actualBackoff = Math.min(baseBackoff, this.maxBackoff);\n    const jitter = actualBackoff * (Math.random() - 0.5);\n    return actualBackoff + jitter;\n  }\n}","map":{"version":3,"names":["encodeClientMessage","parseServerMessage","CLOSE_NORMAL","CLOSE_GOING_AWAY","CLOSE_NO_STATUS","CLOSE_NOT_FOUND","WebSocketManager","constructor","uri","callbacks","webSocketConstructor","verbose","__publicField","socket","state","connectionCount","lastCloseReason","initialBackoff","maxBackoff","retries","serverInactivityThreshold","reconnectDueToServerInactivityTimeout","onOpen","onResume","onMessage","connect","Error","ws","_logVerbose","paused","resetServerInactivityTimeout","onopen","console","log","onerror","error","message","onmessage","serverMessage","JSON","parse","data","type","response","hasSyncedPastLastReconnect","onclose","event","reason","code","msg","scheduleReconnect","socketState","sendMessage","encodedMessage","request","stringify","send","closeAndReconnect","clearTimeout","setTimeout","backoff","nextBackoff","closeReason","close","_","Promise","resolve","r","result","terminate","stop","restart","pause","resume","debug","Date","toISOString","baseBackoff","Math","pow","actualBackoff","min","jitter","random"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/browser/sync/web_socket_manager.ts"],"sourcesContent":["import {\n  ClientMessage,\n  encodeClientMessage,\n  parseServerMessage,\n  ServerMessage,\n} from \"./protocol.js\";\n\nconst CLOSE_NORMAL = 1000;\nconst CLOSE_GOING_AWAY = 1001;\nconst CLOSE_NO_STATUS = 1005;\n/** Convex-specific close code representing a \"404 Not Found\".\n * The edge Onramp accepts websocket upgrades before confirming that the\n * intended destination exists, so this code is sent once we've discovered that\n * the destination does not exist.\n */\nconst CLOSE_NOT_FOUND = 4040;\n\n/**\n * The various states our WebSocket can be in:\n *\n * - \"disconnected\": We don't have a WebSocket, but plan to create one.\n * - \"connecting\": We have created the WebSocket and are waiting for the\n *   `onOpen` callback.\n * - \"ready\": We have an open WebSocket.\n * - \"stopped\": The WebSocket was closed and a new one can be created via `.restart()`.\n * - \"terminated\": We have closed the WebSocket and will never create a new one.\n *\n *\n * WebSocket State Machine\n * -----------------------\n * initialState: disconnected\n * validTransitions:\n *   disconnected:\n *     new WebSocket() -> connecting\n *     terminate() -> terminated\n *   connecting:\n *     onopen -> ready\n *     close() -> disconnected\n *     terminate() -> terminated\n *   ready:\n *     close() -> disconnected\n *     stop() -> stopped\n *     terminate() -> terminated\n *   stopped:\n *     restart() -> connecting\n *     terminate() -> terminated\n * terminalStates:\n *   terminated\n *\n *\n *\n *                                        ┌────────────────┐\n *                ┌────terminate()────────│  disconnected  │◀─┐\n *                │                       └────────────────┘  │\n *                ▼                            │       ▲      │\n *       ┌────────────────┐           new WebSocket()  │      │\n *    ┌─▶│   terminated   │◀──────┐            │       │      │\n *    │  └────────────────┘       │            │       │      │\n *    │           ▲          terminate()       │    close() close()\n *    │      terminate()          │            │       │      │\n *    │           │               │            ▼       │      │\n *    │  ┌────────────────┐       └───────┌────────────────┐  │\n *    │  │    stopped     │──restart()───▶│   connecting   │  │\n *    │  └────────────────┘               └────────────────┘  │\n *    │           ▲                                │          │\n *    │           │                               onopen      │\n *    │           │                                │          │\n *    │           │                                ▼          │\n * terminate()    │                       ┌────────────────┐  │\n *    │           └────────stop()─────────│     ready      │──┘\n *    │                                   └────────────────┘\n *    │                                            │\n *    │                                            │\n *    └────────────────────────────────────────────┘\n *\n * The `connecting` and `ready` state have a sub-state-machine for pausing.\n */\n\ntype Socket =\n  | { state: \"disconnected\" }\n  | { state: \"connecting\"; ws: WebSocket; paused: \"yes\" | \"no\" }\n  | { state: \"ready\"; ws: WebSocket; paused: \"yes\" | \"no\" | \"uninitialized\" }\n  | { state: \"stopped\" }\n  | { state: \"terminated\" };\n\nexport type ReconnectMetadata = {\n  connectionCount: number;\n  lastCloseReason: string | null;\n};\n\nexport type OnMessageResponse = {\n  hasSyncedPastLastReconnect: boolean;\n};\n\n/**\n * A wrapper around a websocket that handles errors, reconnection, and message\n * parsing.\n */\nexport class WebSocketManager {\n  private socket: Socket;\n\n  private connectionCount: number;\n  private lastCloseReason: string | null;\n\n  /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */\n  private readonly initialBackoff: number;\n\n  /** We backoff exponentially, but we need to cap that--this is the jittered max. */\n  private readonly maxBackoff: number;\n\n  /** How many times have we failed consecutively? */\n  private retries: number;\n\n  /** How long before lack of server response causes us to initiate a reconnect,\n   * in ms */\n  private readonly serverInactivityThreshold: number;\n\n  private reconnectDueToServerInactivityTimeout: ReturnType<\n    typeof setTimeout\n  > | null;\n\n  private readonly uri: string;\n  private readonly onOpen: (reconnectMetadata: ReconnectMetadata) => void;\n  private readonly onResume: () => void;\n  private readonly onMessage: (message: ServerMessage) => OnMessageResponse;\n  private readonly webSocketConstructor: typeof WebSocket;\n  private readonly verbose: boolean;\n\n  constructor(\n    uri: string,\n    callbacks: {\n      onOpen: (reconnectMetadata: ReconnectMetadata) => void;\n      onResume: () => void;\n      onMessage: (message: ServerMessage) => OnMessageResponse;\n    },\n    webSocketConstructor: typeof WebSocket,\n    verbose: boolean,\n  ) {\n    this.webSocketConstructor = webSocketConstructor;\n    this.socket = { state: \"disconnected\" };\n    this.connectionCount = 0;\n    this.lastCloseReason = \"InitialConnect\";\n\n    this.initialBackoff = 100;\n    this.maxBackoff = 16000;\n    this.retries = 0;\n\n    this.serverInactivityThreshold = 30000;\n    this.reconnectDueToServerInactivityTimeout = null;\n\n    this.uri = uri;\n    this.onOpen = callbacks.onOpen;\n    this.onResume = callbacks.onResume;\n    this.onMessage = callbacks.onMessage;\n    this.verbose = verbose;\n\n    this.connect();\n  }\n\n  private connect() {\n    if (this.socket.state === \"terminated\") {\n      return;\n    }\n    if (\n      this.socket.state !== \"disconnected\" &&\n      this.socket.state !== \"stopped\"\n    ) {\n      throw new Error(\n        \"Didn't start connection from disconnected state: \" + this.socket.state,\n      );\n    }\n\n    const ws = new this.webSocketConstructor(this.uri);\n    this._logVerbose(\"constructed WebSocket\");\n    this.socket = {\n      state: \"connecting\",\n      ws,\n      paused: \"no\",\n    };\n\n    // Kick off server inactivity timer before WebSocket connection is established\n    // so we can detect cases where handshake fails.\n    // The `onopen` event only fires after the connection is established:\n    // Source: https://datatracker.ietf.org/doc/html/rfc6455#page-19:~:text=_The%20WebSocket%20Connection%20is%20Established_,-and\n    this.resetServerInactivityTimeout();\n\n    ws.onopen = () => {\n      this._logVerbose(\"begin ws.onopen\");\n      if (this.socket.state !== \"connecting\") {\n        throw new Error(\"onopen called with socket not in connecting state\");\n      }\n      this.socket = {\n        state: \"ready\",\n        ws,\n        paused: this.socket.paused === \"yes\" ? \"uninitialized\" : \"no\",\n      };\n      this.resetServerInactivityTimeout();\n      if (this.socket.paused === \"no\") {\n        this.onOpen({\n          connectionCount: this.connectionCount,\n          lastCloseReason: this.lastCloseReason,\n        });\n      }\n\n      if (this.lastCloseReason !== \"InitialConnect\") {\n        console.log(\"WebSocket reconnected\");\n      }\n\n      this.connectionCount += 1;\n      this.lastCloseReason = null;\n    };\n    // NB: The WebSocket API calls `onclose` even if connection fails, so we can route all error paths through `onclose`.\n    ws.onerror = (error) => {\n      const message = (error as ErrorEvent).message;\n      console.log(`WebSocket error: ${message}`);\n    };\n    ws.onmessage = (message) => {\n      this.resetServerInactivityTimeout();\n      const serverMessage = parseServerMessage(JSON.parse(message.data));\n      this._logVerbose(`received ws message with type ${serverMessage.type}`);\n      const response = this.onMessage(serverMessage);\n      if (response.hasSyncedPastLastReconnect) {\n        // Reset backoff to 0 once all outstanding requests are complete.\n        this.retries = 0;\n      }\n    };\n    ws.onclose = (event) => {\n      this._logVerbose(\"begin ws.onclose\");\n      if (this.lastCloseReason === null) {\n        this.lastCloseReason = event.reason ?? \"OnCloseInvoked\";\n      }\n      if (\n        event.code !== CLOSE_NORMAL &&\n        event.code !== CLOSE_GOING_AWAY && // This commonly gets fired on mobile apps when the app is backgrounded\n        event.code !== CLOSE_NO_STATUS &&\n        event.code !== CLOSE_NOT_FOUND // Note that we want to retry on a 404, as it can be transient during a push.\n      ) {\n        let msg = `WebSocket closed with code ${event.code}`;\n        if (event.reason) {\n          msg += `: ${event.reason}`;\n        }\n        console.log(msg);\n      }\n      this.scheduleReconnect();\n      return;\n    };\n  }\n\n  /**\n   * @returns The state of the {@link Socket}.\n   */\n  socketState(): string {\n    return this.socket.state;\n  }\n\n  /**\n   * @param message - A ClientMessage to send.\n   * @returns Whether the message (might have been) sent.\n   */\n  sendMessage(message: ClientMessage) {\n    this._logVerbose(`sending message with type ${message.type}`);\n\n    if (this.socket.state === \"ready\" && this.socket.paused === \"no\") {\n      const encodedMessage = encodeClientMessage(message);\n      const request = JSON.stringify(encodedMessage);\n      try {\n        this.socket.ws.send(request);\n      } catch (error: any) {\n        console.log(\n          `Failed to send message on WebSocket, reconnecting: ${error}`,\n        );\n        this.closeAndReconnect(\"FailedToSendMessage\");\n      }\n      // We are not sure if this was sent or not.\n      return true;\n    }\n    return false;\n  }\n\n  private resetServerInactivityTimeout() {\n    if (this.socket.state === \"terminated\") {\n      // Don't reset any timers if we were trying to terminate.\n      return;\n    }\n    if (this.reconnectDueToServerInactivityTimeout !== null) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n      this.reconnectDueToServerInactivityTimeout = null;\n    }\n    this.reconnectDueToServerInactivityTimeout = setTimeout(() => {\n      this.closeAndReconnect(\"InactiveServer\");\n    }, this.serverInactivityThreshold);\n  }\n\n  private scheduleReconnect() {\n    this.socket = { state: \"disconnected\" };\n    const backoff = this.nextBackoff();\n    console.log(`Attempting reconnect in ${backoff}ms`);\n    setTimeout(() => this.connect(), backoff);\n  }\n\n  /**\n   * Close the WebSocket and schedule a reconnect.\n   *\n   * This should be used when we hit an error and would like to restart the session.\n   */\n  private closeAndReconnect(closeReason: string) {\n    this._logVerbose(`begin closeAndReconnect with reason ${closeReason}`);\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"terminated\":\n      case \"stopped\":\n        // Nothing to do if we don't have a WebSocket.\n        return;\n      case \"connecting\":\n      case \"ready\": {\n        this.lastCloseReason = closeReason;\n        // Close the old socket asynchronously, we'll open a new socket in reconnect.\n        void this.close();\n        this.scheduleReconnect();\n        return;\n      }\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Close the WebSocket, being careful to clear the onclose handler to avoid re-entrant\n   * calls. Use this instead of directly calling `ws.close()`\n   *\n   * It is the callers responsibility to update the state after this method is called so that the\n   * closed socket is not accessible or used again after this method is called\n   */\n  private close(): Promise<void> {\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"terminated\":\n      case \"stopped\":\n        // Nothing to do if we don't have a WebSocket.\n        return Promise.resolve();\n      case \"connecting\": {\n        const ws = this.socket.ws;\n        return new Promise((r) => {\n          ws.onclose = () => {\n            this._logVerbose(\"Closed after connecting\");\n            r();\n          };\n          ws.onopen = () => {\n            this._logVerbose(\"Opened after connecting\");\n            ws.close();\n          };\n        });\n      }\n      case \"ready\": {\n        this._logVerbose(\"ws.close called\");\n        const ws = this.socket.ws;\n        const result: Promise<void> = new Promise((r) => {\n          ws.onclose = () => {\n            r();\n          };\n        });\n        ws.close();\n        return result;\n      }\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n        const _: never = this.socket;\n        return Promise.resolve();\n      }\n    }\n  }\n\n  /**\n   * Close the WebSocket and do not reconnect.\n   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.\n   */\n  terminate(): Promise<void> {\n    if (this.reconnectDueToServerInactivityTimeout) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n    }\n    switch (this.socket.state) {\n      case \"terminated\":\n      case \"stopped\":\n      case \"disconnected\":\n      case \"connecting\":\n      case \"ready\": {\n        const result = this.close();\n        this.socket = { state: \"terminated\" };\n        return result;\n      }\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n        throw new Error(\n          `Invalid websocket state: ${(this.socket as any).state}`,\n        );\n      }\n    }\n  }\n\n  stop(): Promise<void> {\n    switch (this.socket.state) {\n      case \"terminated\":\n        // If we're terminating we ignore stop\n        return Promise.resolve();\n      case \"connecting\":\n      case \"stopped\":\n      case \"disconnected\":\n      case \"ready\": {\n        const result = this.close();\n        this.socket = { state: \"stopped\" };\n        return result;\n      }\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n        return Promise.resolve();\n      }\n    }\n  }\n\n  /**\n   * Create a new WebSocket after a previous `stop()`, unless `terminate()` was\n   * called before.\n   */\n  restart(): void {\n    switch (this.socket.state) {\n      case \"stopped\":\n        break;\n      case \"terminated\":\n        // If we're terminating we ignore restart\n        return;\n      case \"connecting\":\n      case \"ready\":\n      case \"disconnected\":\n        throw new Error(\"`restart()` is only valid after `stop()`\");\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n    this.connect();\n  }\n\n  pause(): void {\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"stopped\":\n      case \"terminated\":\n        // If already stopped or stopping ignore.\n        return;\n      case \"connecting\":\n      case \"ready\": {\n        this.socket = { ...this.socket, paused: \"yes\" };\n        return;\n      }\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n        return;\n      }\n    }\n  }\n\n  /**\n   * Resume the state machine if previously paused.\n   */\n  resume(): void {\n    switch (this.socket.state) {\n      case \"connecting\":\n        this.socket = { ...this.socket, paused: \"no\" };\n        return;\n      case \"ready\":\n        if (this.socket.paused === \"uninitialized\") {\n          this.socket = { ...this.socket, paused: \"no\" };\n          this.onOpen({\n            connectionCount: this.connectionCount,\n            lastCloseReason: this.lastCloseReason,\n          });\n        } else if (this.socket.paused === \"yes\") {\n          this.socket = { ...this.socket, paused: \"no\" };\n          this.onResume();\n        }\n        return;\n      case \"terminated\":\n      case \"stopped\":\n      case \"disconnected\":\n        // Ignore resume if not paused, perhaps we already resumed.\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n    this.connect();\n  }\n\n  private _logVerbose(message: string) {\n    if (this.verbose) {\n      console.debug(`${new Date().toISOString()} ${message}`);\n    }\n  }\n\n  private nextBackoff(): number {\n    const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);\n    this.retries += 1;\n    const actualBackoff = Math.min(baseBackoff, this.maxBackoff);\n    const jitter = actualBackoff * (Math.random() - 0.5);\n    return actualBackoff + jitter;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}