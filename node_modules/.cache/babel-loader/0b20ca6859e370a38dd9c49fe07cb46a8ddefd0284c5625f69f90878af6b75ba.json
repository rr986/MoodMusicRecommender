{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { validateDeploymentUrl } from \"../common/index.js\";\nimport { BaseConvexClient } from \"./index.js\";\nimport { getFunctionName } from \"../server/api.js\";\nlet defaultWebSocketConstructor;\nexport function setDefaultWebSocketConstructor(ws) {\n  defaultWebSocketConstructor = ws;\n}\nexport class ConvexClient {\n  /**\n   * Construct a client and immediately initiate a WebSocket connection to the passed address.\n   *\n   * @public\n   */\n  constructor(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    __publicField(this, \"listeners\");\n    __publicField(this, \"_client\");\n    // A synthetic server event to run callbacks the first time\n    __publicField(this, \"callNewListenersWithCurrentValuesTimer\");\n    __publicField(this, \"_closed\");\n    __publicField(this, \"disabled\");\n    if (options.skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    const {\n      disabled,\n      ...baseOptions\n    } = options;\n    this._closed = false;\n    this.disabled = !!disabled;\n    if (defaultWebSocketConstructor && !(\"webSocketConstructor\" in baseOptions) && typeof WebSocket === \"undefined\") {\n      baseOptions.webSocketConstructor = defaultWebSocketConstructor;\n    }\n    if (typeof window === \"undefined\" && !(\"unsavedChangesWarning\" in baseOptions)) {\n      baseOptions.unsavedChangesWarning = false;\n    }\n    if (!this.disabled) {\n      this._client = new BaseConvexClient(address, updatedQueries => this._transition(updatedQueries), baseOptions);\n    }\n    this.listeners = /* @__PURE__ */new Set();\n  }\n  /**\n   * Once closed no registered callbacks will fire again.\n   */\n  get closed() {\n    return this._closed;\n  }\n  get client() {\n    if (this._client) return this._client;\n    throw new Error(\"ConvexClient is disabled\");\n  }\n  /**\n   * Call a callback whenever a new result for a query is received. The callback\n   * will run soon after being registered if a result for the query is already\n   * in memory.\n   *\n   * The return value is an {@link Unsubscribe} object which is both a function\n   * an an object with properties. Both of the patterns below work with this object:\n   *\n   *```ts\n   * // call the return value as a function\n   * const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) => {\n   *   console.log(messages);\n   * });\n   * unsubscribe();\n   *\n   * // unpack the return value into its properties\n   * const {\n   *   getCurrentValue,\n   *   unsubscribe,\n   * } = client.onUpdate(api.messages.list, {}, (messages) => {\n   *   console.log(messages);\n   * });\n   *```\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - The arguments to run the query with.\n   * @param callback - Function to call when the query result updates.\n   * @param onError - Function to call when the query result updates with an error.\n   * If not provided, errors will be thrown instead of calling the callback.\n   *\n   * @return an {@link Unsubscribe} function to stop calling the onUpdate function.\n   */\n  onUpdate(query, args, callback, onError) {\n    if (this.disabled) {\n      const disabledUnsubscribe = () => {};\n      const unsubscribeProps2 = {\n        unsubscribe: disabledUnsubscribe,\n        getCurrentValue: () => void 0,\n        getQueryLogs: () => void 0\n      };\n      Object.assign(disabledUnsubscribe, unsubscribeProps2);\n      return disabledUnsubscribe;\n    }\n    const {\n      queryToken,\n      unsubscribe\n    } = this.client.subscribe(getFunctionName(query), args);\n    const queryInfo = {\n      queryToken,\n      callback,\n      onError,\n      unsubscribe,\n      hasEverRun: false,\n      query,\n      args\n    };\n    this.listeners.add(queryInfo);\n    if (this.queryResultReady(queryToken) && this.callNewListenersWithCurrentValuesTimer === void 0) {\n      this.callNewListenersWithCurrentValuesTimer = setTimeout(() => this.callNewListenersWithCurrentValues(), 0);\n    }\n    const unsubscribeProps = {\n      unsubscribe: () => {\n        if (this.closed) {\n          return;\n        }\n        this.listeners.delete(queryInfo);\n        unsubscribe();\n      },\n      getCurrentValue: () => this.client.localQueryResultByToken(queryToken),\n      getQueryLogs: () => this.client.localQueryLogs(queryToken)\n    };\n    const ret = unsubscribeProps.unsubscribe;\n    Object.assign(ret, unsubscribeProps);\n    return ret;\n  }\n  // Run all callbacks that have never been run before if they have a query\n  // result available now.\n  callNewListenersWithCurrentValues() {\n    this.callNewListenersWithCurrentValuesTimer = void 0;\n    this._transition([], true);\n  }\n  queryResultReady(queryToken) {\n    return this.client.hasLocalQueryResultByToken(queryToken);\n  }\n  async close() {\n    if (this.disabled) return;\n    this.listeners.clear();\n    this._closed = true;\n    return this.client.close();\n  }\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */\n  setAuth(fetchToken, onChange) {\n    this.client.setAuth(fetchToken, onChange ?? (() => {}));\n  }\n  /**\n   * @internal\n   */\n  setAdminAuth(token, identity) {\n    if (this.closed) {\n      throw new Error(\"ConvexClient has already been closed.\");\n    }\n    if (this.disabled) return;\n    this.client.setAdminAuth(token, identity);\n  }\n  /**\n   * @internal\n   */\n  _transition(updatedQueries) {\n    let callNewListeners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    for (const queryInfo of this.listeners) {\n      const {\n        callback,\n        queryToken,\n        onError,\n        hasEverRun\n      } = queryInfo;\n      if (updatedQueries.includes(queryToken) || callNewListeners && !hasEverRun && this.client.hasLocalQueryResultByToken(queryToken)) {\n        queryInfo.hasEverRun = true;\n        let newValue;\n        try {\n          newValue = this.client.localQueryResultByToken(queryToken);\n        } catch (error) {\n          if (!(error instanceof Error)) throw error;\n          if (onError) {\n            onError(error, \"Second argument to onUpdate onError is reserved for later use\");\n          } else {\n            void Promise.reject(error);\n          }\n          continue;\n        }\n        callback(newValue, \"Second argument to onUpdate callback is reserved for later use\");\n      }\n    }\n  }\n  /**\n   * Execute a mutation function.\n   *\n   * @param mutation - A {@link server.FunctionReference} for the public mutation\n   * to run.\n   * @param args - An arguments object for the mutation.\n   * @param options - A {@link MutationOptions} options object for the mutation.\n   * @returns A promise of the mutation's result.\n   */\n  async mutation(mutation, args) {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    return await this.client.mutation(getFunctionName(mutation), args);\n  }\n  /**\n   * Execute an action function.\n   *\n   * @param action - A {@link server.FunctionReference} for the public action\n   * to run.\n   * @param args - An arguments object for the action.\n   * @returns A promise of the action's result.\n   */\n  async action(action, args) {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    return await this.client.action(getFunctionName(action), args);\n  }\n  /**\n   * Fetch a query result once.\n   *\n   * @param query - A {@link server.FunctionReference} for the public query\n   * to run.\n   * @param args - An arguments object for the query.\n   * @returns A promise of the query's result.\n   */\n  async query(query, args) {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    const value = this.client.localQueryResult(getFunctionName(query), args);\n    if (value !== void 0) return Promise.resolve(value);\n    return new Promise((resolve, reject) => {\n      const {\n        unsubscribe\n      } = this.onUpdate(query, args, value2 => {\n        unsubscribe();\n        resolve(value2);\n      }, e => {\n        unsubscribe();\n        reject(e);\n      });\n    });\n  }\n}","map":{"version":3,"names":["validateDeploymentUrl","BaseConvexClient","getFunctionName","defaultWebSocketConstructor","setDefaultWebSocketConstructor","ws","ConvexClient","constructor","address","options","arguments","length","undefined","__publicField","skipConvexDeploymentUrlCheck","disabled","baseOptions","_closed","WebSocket","webSocketConstructor","window","unsavedChangesWarning","_client","updatedQueries","_transition","listeners","Set","closed","client","Error","onUpdate","query","args","callback","onError","disabledUnsubscribe","unsubscribeProps2","unsubscribe","getCurrentValue","getQueryLogs","Object","assign","queryToken","subscribe","queryInfo","hasEverRun","add","queryResultReady","callNewListenersWithCurrentValuesTimer","setTimeout","callNewListenersWithCurrentValues","unsubscribeProps","delete","localQueryResultByToken","localQueryLogs","ret","hasLocalQueryResultByToken","close","clear","setAuth","fetchToken","onChange","setAdminAuth","token","identity","callNewListeners","includes","newValue","error","Promise","reject","mutation","action","value","localQueryResult","resolve","value2","e"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/browser/simple_client.ts"],"sourcesContent":["import { validateDeploymentUrl } from \"../common/index.js\";\nimport {\n  BaseConvexClient,\n  BaseConvexClientOptions,\n  QueryToken,\n  UserIdentityAttributes,\n} from \"./index.js\";\nimport {\n  FunctionArgs,\n  FunctionReference,\n  FunctionReturnType,\n} from \"../server/index.js\";\nimport { getFunctionName } from \"../server/api.js\";\nimport { AuthTokenFetcher } from \"./sync/authentication_manager.js\";\n\n// In Node.js builds this points to a bundled WebSocket implementation. If no\n// WebSocket implementation is manually specified or globally available,\n// this one is used.\nlet defaultWebSocketConstructor: typeof WebSocket | undefined;\n\n/** internal */\nexport function setDefaultWebSocketConstructor(ws: typeof WebSocket) {\n  defaultWebSocketConstructor = ws;\n}\n\nexport type ConvexClientOptions = BaseConvexClientOptions & {\n  /**\n   * `disabled` makes onUpdate callback registration a no-op and actions,\n   * mutations and one-shot queries throw. Setting disabled to true may be\n   * useful for server-side rendering, where subscriptions don't make sense.\n   */\n  disabled?: boolean;\n  /**\n   * Whether to prompt users in browsers about queued or in-flight mutations.\n   * This only works in environments where `window.onbeforeunload` is available.\n   *\n   * Defaults to true when `window` is defined, otherwise false.\n   */\n  unsavedChangesWarning?: boolean;\n};\n\n/**\n * Stops callbacks from running.\n *\n * @public\n */\nexport type Unsubscribe<T> = {\n  /** Stop calling callback when query results changes. If this is the last listener on this query, stop received updates. */\n  (): void;\n  /** Stop calling callback when query results changes. If this is the last listener on this query, stop received updates. */\n  unsubscribe(): void;\n  /** Get the last known value, possibly with local optimistic updates applied. */\n  getCurrentValue(): T | undefined;\n  /** @internal */\n  getQueryLogs(): string[] | undefined;\n};\n\n/**\n * Subscribes to Convex query functions and executes mutations and actions over a WebSocket.\n *\n * Optimistic updates for mutations are not provided for this client.\n * Third party clients may choose to wrap {@link browser.BaseConvexClient} for additional control.\n *\n * ```ts\n * const client = new ConvexClient(\"https://happy-otter-123.convex.cloud\");\n * const unsubscribe = client.onUpdate(api.messages.list, (messages) => {\n *   console.log(messages[0].body);\n * });\n * ```\n *\n * @public\n */\nexport class ConvexClient {\n  private listeners: Set<QueryInfo>;\n  private _client: BaseConvexClient | undefined;\n  // A synthetic server event to run callbacks the first time\n  private callNewListenersWithCurrentValuesTimer:\n    | ReturnType<typeof setTimeout>\n    | undefined;\n  private _closed: boolean;\n  disabled: boolean;\n  /**\n   * Once closed no registered callbacks will fire again.\n   */\n  get closed(): boolean {\n    return this._closed;\n  }\n  get client(): BaseConvexClient {\n    if (this._client) return this._client;\n    throw new Error(\"ConvexClient is disabled\");\n  }\n\n  /**\n   * Construct a client and immediately initiate a WebSocket connection to the passed address.\n   *\n   * @public\n   */\n  constructor(address: string, options: ConvexClientOptions = {}) {\n    if (options.skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    const { disabled, ...baseOptions } = options;\n    this._closed = false;\n    this.disabled = !!disabled;\n    if (\n      defaultWebSocketConstructor &&\n      !(\"webSocketConstructor\" in baseOptions) &&\n      typeof WebSocket === \"undefined\"\n    ) {\n      baseOptions.webSocketConstructor = defaultWebSocketConstructor;\n    }\n    if (\n      typeof window === \"undefined\" &&\n      !(\"unsavedChangesWarning\" in baseOptions)\n    ) {\n      baseOptions.unsavedChangesWarning = false;\n    }\n    if (!this.disabled) {\n      this._client = new BaseConvexClient(\n        address,\n        (updatedQueries) => this._transition(updatedQueries),\n        baseOptions,\n      );\n    }\n    this.listeners = new Set();\n  }\n\n  /**\n   * Call a callback whenever a new result for a query is received. The callback\n   * will run soon after being registered if a result for the query is already\n   * in memory.\n   *\n   * The return value is an {@link Unsubscribe} object which is both a function\n   * an an object with properties. Both of the patterns below work with this object:\n   *\n   *```ts\n   * // call the return value as a function\n   * const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) => {\n   *   console.log(messages);\n   * });\n   * unsubscribe();\n   *\n   * // unpack the return value into its properties\n   * const {\n   *   getCurrentValue,\n   *   unsubscribe,\n   * } = client.onUpdate(api.messages.list, {}, (messages) => {\n   *   console.log(messages);\n   * });\n   *```\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - The arguments to run the query with.\n   * @param callback - Function to call when the query result updates.\n   * @param onError - Function to call when the query result updates with an error.\n   * If not provided, errors will be thrown instead of calling the callback.\n   *\n   * @return an {@link Unsubscribe} function to stop calling the onUpdate function.\n   */\n  onUpdate<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    args: FunctionArgs<Query>,\n    callback: (result: FunctionReturnType<Query>) => unknown,\n    onError?: (e: Error) => unknown,\n  ): Unsubscribe<Query[\"_returnType\"]> {\n    if (this.disabled) {\n      const disabledUnsubscribe = (() => {}) as Unsubscribe<\n        Query[\"_returnType\"]\n      >;\n      const unsubscribeProps: RemoveCallSignature<\n        Unsubscribe<Query[\"_returnType\"]>\n      > = {\n        unsubscribe: disabledUnsubscribe,\n        getCurrentValue: () => undefined,\n        getQueryLogs: () => undefined,\n      };\n      Object.assign(disabledUnsubscribe, unsubscribeProps);\n      return disabledUnsubscribe;\n    }\n\n    // BaseConvexClient takes care of deduplicating queries subscriptions...\n    const { queryToken, unsubscribe } = this.client.subscribe(\n      getFunctionName(query),\n      args,\n    );\n\n    // ...but we still need to bookkeep callbacks to actually call them.\n    const queryInfo: QueryInfo = {\n      queryToken,\n      callback,\n      onError,\n      unsubscribe,\n      hasEverRun: false,\n      query,\n      args,\n    };\n    this.listeners.add(queryInfo);\n\n    // If the callback is registered for a query with a result immediately available\n    // schedule a fake transition to call the callback soon instead of waiting for\n    // a new server update (which could take seconds or days).\n    if (\n      this.queryResultReady(queryToken) &&\n      this.callNewListenersWithCurrentValuesTimer === undefined\n    ) {\n      this.callNewListenersWithCurrentValuesTimer = setTimeout(\n        () => this.callNewListenersWithCurrentValues(),\n        0,\n      );\n    }\n\n    const unsubscribeProps: RemoveCallSignature<\n      Unsubscribe<Query[\"_returnType\"]>\n    > = {\n      unsubscribe: () => {\n        if (this.closed) {\n          // all unsubscribes already ran\n          return;\n        }\n        this.listeners.delete(queryInfo);\n        unsubscribe();\n      },\n      getCurrentValue: () => this.client.localQueryResultByToken(queryToken),\n      getQueryLogs: () => this.client.localQueryLogs(queryToken),\n    };\n    const ret = unsubscribeProps.unsubscribe as Unsubscribe<\n      Query[\"_returnType\"]\n    >;\n    Object.assign(ret, unsubscribeProps);\n    return ret;\n  }\n\n  // Run all callbacks that have never been run before if they have a query\n  // result available now.\n  private callNewListenersWithCurrentValues() {\n    this.callNewListenersWithCurrentValuesTimer = undefined;\n    this._transition([], true);\n  }\n\n  private queryResultReady(queryToken: QueryToken): boolean {\n    return this.client.hasLocalQueryResultByToken(queryToken);\n  }\n\n  async close() {\n    if (this.disabled) return;\n    // prevent pending updates\n    this.listeners.clear();\n    this._closed = true;\n    return this.client.close();\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */\n  setAuth(\n    fetchToken: AuthTokenFetcher,\n    onChange?: (isAuthenticated: boolean) => void,\n  ) {\n    this.client.setAuth(\n      fetchToken,\n      onChange ??\n        (() => {\n          // Do nothing\n        }),\n    );\n  }\n\n  /**\n   * @internal\n   */\n  setAdminAuth(token: string, identity?: UserIdentityAttributes) {\n    if (this.closed) {\n      throw new Error(\"ConvexClient has already been closed.\");\n    }\n    if (this.disabled) return;\n    this.client.setAdminAuth(token, identity);\n  }\n\n  /**\n   * @internal\n   */\n  _transition(updatedQueries: QueryToken[], callNewListeners = false) {\n    // Deduping subscriptions happens in the BaseConvexClient, so not much to do here.\n\n    // Call all callbacks in the order they were registered\n    for (const queryInfo of this.listeners) {\n      const { callback, queryToken, onError, hasEverRun } = queryInfo;\n      if (\n        updatedQueries.includes(queryToken) ||\n        (callNewListeners &&\n          !hasEverRun &&\n          this.client.hasLocalQueryResultByToken(queryToken))\n      ) {\n        queryInfo.hasEverRun = true;\n        let newValue;\n        try {\n          newValue = this.client.localQueryResultByToken(queryToken);\n        } catch (error) {\n          if (!(error instanceof Error)) throw error;\n          if (onError) {\n            onError(\n              error,\n              \"Second argument to onUpdate onError is reserved for later use\",\n            );\n          } else {\n            // Make some noise without unsubscribing or failing to call other callbacks.\n            void Promise.reject(error);\n          }\n          continue;\n        }\n        callback(\n          newValue,\n          \"Second argument to onUpdate callback is reserved for later use\",\n        );\n      }\n    }\n  }\n\n  /**\n   * Execute a mutation function.\n   *\n   * @param mutation - A {@link server.FunctionReference} for the public mutation\n   * to run.\n   * @param args - An arguments object for the mutation.\n   * @param options - A {@link MutationOptions} options object for the mutation.\n   * @returns A promise of the mutation's result.\n   */\n  async mutation<Mutation extends FunctionReference<\"mutation\">>(\n    mutation: Mutation,\n    args: FunctionArgs<Mutation>,\n  ): Promise<Awaited<FunctionReturnType<Mutation>>> {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    return await this.client.mutation(getFunctionName(mutation), args);\n  }\n\n  /**\n   * Execute an action function.\n   *\n   * @param action - A {@link server.FunctionReference} for the public action\n   * to run.\n   * @param args - An arguments object for the action.\n   * @returns A promise of the action's result.\n   */\n  async action<Action extends FunctionReference<\"action\">>(\n    action: Action,\n    args: FunctionArgs<Action>,\n  ): Promise<Awaited<FunctionReturnType<Action>>> {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    return await this.client.action(getFunctionName(action), args);\n  }\n\n  /**\n   * Fetch a query result once.\n   *\n   * @param query - A {@link server.FunctionReference} for the public query\n   * to run.\n   * @param args - An arguments object for the query.\n   * @returns A promise of the query's result.\n   */\n  async query<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    args: Query[\"_args\"],\n  ): Promise<Awaited<Query[\"_returnType\"]>> {\n    if (this.disabled) throw new Error(\"ConvexClient is disabled\");\n    const value = this.client.localQueryResult(getFunctionName(query), args) as\n      | Awaited<Query[\"_returnType\"]>\n      | undefined;\n    if (value !== undefined) return Promise.resolve(value);\n\n    return new Promise((resolve, reject) => {\n      const { unsubscribe } = this.onUpdate(\n        query,\n        args,\n        (value) => {\n          unsubscribe();\n          resolve(value);\n        },\n        (e: Error) => {\n          unsubscribe();\n          reject(e);\n        },\n      );\n    });\n  }\n}\n\n// internal information tracked about each registered callback\ntype QueryInfo = {\n  callback: (result: any, meta: unknown) => unknown;\n  onError: ((e: Error, meta: unknown) => unknown) | undefined;\n  unsubscribe: () => void;\n  queryToken: QueryToken;\n  hasEverRun: boolean;\n  // query and args are just here for debugging, the queryToken is authoritative\n  query: FunctionReference<\"query\">;\n  args: any;\n};\n\ntype RemoveCallSignature<T> = Omit<T, never>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}