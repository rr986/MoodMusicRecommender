{"ast":null,"code":"\"use strict\";\n\nimport { convexToJson, jsonToConvex } from \"../../values/index.js\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { functionName } from \"../../server/api.js\";\nimport { extractReferencePath, isFunctionHandle } from \"../components/index.js\";\nfunction syscallArgs(requestId, functionReference, args) {\n  const address = getFunctionAddress(functionReference);\n  return {\n    ...address,\n    args: convexToJson(parseArgs(args)),\n    version,\n    requestId\n  };\n}\nexport function getFunctionAddress(functionReference) {\n  let functionAddress;\n  if (typeof functionReference === \"string\") {\n    if (isFunctionHandle(functionReference)) {\n      functionAddress = {\n        functionHandle: functionReference\n      };\n    } else {\n      functionAddress = {\n        name: functionReference\n      };\n    }\n  } else if (functionReference[functionName]) {\n    functionAddress = {\n      name: functionReference[functionName]\n    };\n  } else {\n    const referencePath = extractReferencePath(functionReference);\n    if (!referencePath) {\n      throw new Error(`${functionReference} is not a functionReference`);\n    }\n    functionAddress = {\n      reference: referencePath\n    };\n  }\n  return functionAddress;\n}\nexport function setupActionCalls(requestId) {\n  return {\n    runQuery: async (query, args) => {\n      const result = await performAsyncSyscall(\"1.0/actions/query\", syscallArgs(requestId, query, args));\n      return jsonToConvex(result);\n    },\n    runMutation: async (mutation, args) => {\n      const result = await performAsyncSyscall(\"1.0/actions/mutation\", syscallArgs(requestId, mutation, args));\n      return jsonToConvex(result);\n    },\n    runAction: async (action, args) => {\n      const result = await performAsyncSyscall(\"1.0/actions/action\", syscallArgs(requestId, action, args));\n      return jsonToConvex(result);\n    }\n  };\n}","map":{"version":3,"names":["convexToJson","jsonToConvex","version","performAsyncSyscall","parseArgs","functionName","extractReferencePath","isFunctionHandle","syscallArgs","requestId","functionReference","args","address","getFunctionAddress","functionAddress","functionHandle","name","referencePath","Error","reference","setupActionCalls","runQuery","query","result","runMutation","mutation","runAction","action"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/server/impl/actions_impl.ts"],"sourcesContent":["import { convexToJson, jsonToConvex, Value } from \"../../values/index.js\";\nimport { version } from \"../../index.js\";\nimport { performAsyncSyscall } from \"./syscall.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { functionName, FunctionReference } from \"../../server/api.js\";\nimport { extractReferencePath, isFunctionHandle } from \"../components/index.js\";\n\nfunction syscallArgs(\n  requestId: string,\n  functionReference: any,\n  args?: Record<string, Value>,\n) {\n  const address = getFunctionAddress(functionReference);\n  return {\n    ...address,\n    args: convexToJson(parseArgs(args)),\n    version,\n    requestId,\n  };\n}\n\nexport function getFunctionAddress(functionReference: any) {\n  // The `run*` syscalls expect either a UDF path at \"name\" or a serialized\n  // reference at \"reference\". Dispatch on `functionReference` to coerce\n  // it to one ore the other.\n  let functionAddress;\n\n  // Legacy path for passing in UDF paths directly as function references.\n  if (typeof functionReference === \"string\") {\n    if (isFunctionHandle(functionReference)) {\n      functionAddress = { functionHandle: functionReference };\n    } else {\n      functionAddress = { name: functionReference };\n    }\n  }\n  // Path for passing in a `FunctionReference`, either from `api` or directly\n  // created from a UDF path with `makeFunctionReference`.\n  else if (functionReference[functionName]) {\n    functionAddress = { name: functionReference[functionName] };\n  }\n  // Reference to a component's function derived from `app` or `component`.\n  else {\n    const referencePath = extractReferencePath(functionReference);\n    if (!referencePath) {\n      throw new Error(`${functionReference} is not a functionReference`);\n    }\n    functionAddress = { reference: referencePath };\n  }\n  return functionAddress;\n}\n\nexport function setupActionCalls(requestId: string) {\n  return {\n    runQuery: async (\n      query: FunctionReference<\"query\", \"public\" | \"internal\">,\n      args?: Record<string, Value>,\n    ): Promise<any> => {\n      const result = await performAsyncSyscall(\n        \"1.0/actions/query\",\n        syscallArgs(requestId, query, args),\n      );\n      return jsonToConvex(result);\n    },\n    runMutation: async (\n      mutation: FunctionReference<\"mutation\", \"public\" | \"internal\">,\n      args?: Record<string, Value>,\n    ): Promise<any> => {\n      const result = await performAsyncSyscall(\n        \"1.0/actions/mutation\",\n        syscallArgs(requestId, mutation, args),\n      );\n      return jsonToConvex(result);\n    },\n    runAction: async (\n      action: FunctionReference<\"action\", \"public\" | \"internal\">,\n      args?: Record<string, Value>,\n    ): Promise<any> => {\n      const result = await performAsyncSyscall(\n        \"1.0/actions/action\",\n        syscallArgs(requestId, action, args),\n      );\n      return jsonToConvex(result);\n    },\n  };\n}\n"],"mappings":";;AAAA,SAASA,YAAA,EAAcC,YAAA,QAA2B;AAClD,SAASC,OAAA,QAAe;AACxB,SAASC,mBAAA,QAA2B;AACpC,SAASC,SAAA,QAAiB;AAC1B,SAASC,YAAA,QAAuC;AAChD,SAASC,oBAAA,EAAsBC,gBAAA,QAAwB;AAEvD,SAASC,YACPC,SAAA,EACAC,iBAAA,EACAC,IAAA,EACA;EACA,MAAMC,OAAA,GAAUC,kBAAA,CAAmBH,iBAAiB;EACpD,OAAO;IACL,GAAGE,OAAA;IACHD,IAAA,EAAMX,YAAA,CAAaI,SAAA,CAAUO,IAAI,CAAC;IAClCT,OAAA;IACAO;EACF;AACF;AAEO,gBAASI,mBAAmBH,iBAAA,EAAwB;EAIzD,IAAII,eAAA;EAGJ,IAAI,OAAOJ,iBAAA,KAAsB,UAAU;IACzC,IAAIH,gBAAA,CAAiBG,iBAAiB,GAAG;MACvCI,eAAA,GAAkB;QAAEC,cAAA,EAAgBL;MAAkB;IACxD,OAAO;MACLI,eAAA,GAAkB;QAAEE,IAAA,EAAMN;MAAkB;IAC9C;EACF,WAGSA,iBAAA,CAAkBL,YAAY,GAAG;IACxCS,eAAA,GAAkB;MAAEE,IAAA,EAAMN,iBAAA,CAAkBL,YAAY;IAAE;EAC5D,OAEK;IACH,MAAMY,aAAA,GAAgBX,oBAAA,CAAqBI,iBAAiB;IAC5D,IAAI,CAACO,aAAA,EAAe;MAClB,MAAM,IAAIC,KAAA,CAAM,GAAGR,iBAAA,6BAA8C;IACnE;IACAI,eAAA,GAAkB;MAAEK,SAAA,EAAWF;IAAc;EAC/C;EACA,OAAOH,eAAA;AACT;AAEO,gBAASM,iBAAiBX,SAAA,EAAmB;EAClD,OAAO;IACLY,QAAA,EAAU,MAAAA,CACRC,KAAA,EACAX,IAAA,KACiB;MACjB,MAAMY,MAAA,GAAS,MAAMpB,mBAAA,CACnB,qBACAK,WAAA,CAAYC,SAAA,EAAWa,KAAA,EAAOX,IAAI,CACpC;MACA,OAAOV,YAAA,CAAasB,MAAM;IAC5B;IACAC,WAAA,EAAa,MAAAA,CACXC,QAAA,EACAd,IAAA,KACiB;MACjB,MAAMY,MAAA,GAAS,MAAMpB,mBAAA,CACnB,wBACAK,WAAA,CAAYC,SAAA,EAAWgB,QAAA,EAAUd,IAAI,CACvC;MACA,OAAOV,YAAA,CAAasB,MAAM;IAC5B;IACAG,SAAA,EAAW,MAAAA,CACTC,MAAA,EACAhB,IAAA,KACiB;MACjB,MAAMY,MAAA,GAAS,MAAMpB,mBAAA,CACnB,sBACAK,WAAA,CAAYC,SAAA,EAAWkB,MAAA,EAAQhB,IAAI,CACrC;MACA,OAAOV,YAAA,CAAasB,MAAM;IAC5B;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}