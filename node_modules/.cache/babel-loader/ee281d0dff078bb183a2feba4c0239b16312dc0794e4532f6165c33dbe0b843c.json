{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { jsonToConvex } from \"../../values/index.js\";\nimport { logToConsole } from \"../logging.js\";\nexport class RequestManager {\n  constructor() {\n    __publicField(this, \"inflightRequests\");\n    __publicField(this, \"requestsOlderThanRestart\");\n    this.inflightRequests = /* @__PURE__ */new Map();\n    this.requestsOlderThanRestart = /* @__PURE__ */new Set();\n  }\n  request(message, sent) {\n    const result = new Promise(resolve => {\n      const status = sent ? \"Requested\" : \"NotSent\";\n      this.inflightRequests.set(message.requestId, {\n        message,\n        status: {\n          status,\n          requestedAt: /* @__PURE__ */new Date(),\n          onResult: resolve\n        }\n      });\n    });\n    return result;\n  }\n  /**\n   * Update the state after receiving a response.\n   *\n   * @returns A RequestId if the request is complete and its optimistic update\n   * can be dropped, null otherwise.\n   */\n  onResponse(response) {\n    const requestInfo = this.inflightRequests.get(response.requestId);\n    if (requestInfo === void 0) {\n      return null;\n    }\n    if (requestInfo.status.status === \"Completed\") {\n      return null;\n    }\n    const udfType = requestInfo.message.type === \"Mutation\" ? \"mutation\" : \"action\";\n    const udfPath = requestInfo.message.udfPath;\n    for (const line of response.logLines) {\n      logToConsole(\"info\", udfType, udfPath, line);\n    }\n    const status = requestInfo.status;\n    let onResolve;\n    if (response.success) {\n      onResolve = () => status.onResult({\n        success: true,\n        logLines: response.logLines,\n        value: jsonToConvex(response.result)\n      });\n    } else {\n      const errorMessage = response.result;\n      const {\n        errorData\n      } = response;\n      logToConsole(\"error\", udfType, udfPath, errorMessage);\n      onResolve = () => status.onResult({\n        success: false,\n        errorMessage,\n        errorData: errorData !== void 0 ? jsonToConvex(errorData) : void 0,\n        logLines: response.logLines\n      });\n    }\n    if (response.type === \"ActionResponse\" || !response.success) {\n      onResolve();\n      this.inflightRequests.delete(response.requestId);\n      this.requestsOlderThanRestart.delete(response.requestId);\n      return response.requestId;\n    }\n    requestInfo.status = {\n      status: \"Completed\",\n      ts: response.ts,\n      onResolve\n    };\n    return null;\n  }\n  // Remove and returns completed requests.\n  removeCompleted(ts) {\n    const completeRequests = /* @__PURE__ */new Set();\n    for (const [requestId, requestInfo] of this.inflightRequests.entries()) {\n      const status = requestInfo.status;\n      if (status.status === \"Completed\" && status.ts.lessThanOrEqual(ts)) {\n        status.onResolve();\n        completeRequests.add(requestId);\n        this.inflightRequests.delete(requestId);\n        this.requestsOlderThanRestart.delete(requestId);\n      }\n    }\n    return completeRequests;\n  }\n  restart() {\n    this.requestsOlderThanRestart = new Set(this.inflightRequests.keys());\n    const allMessages = [];\n    for (const [requestId, value] of this.inflightRequests) {\n      if (value.status.status === \"NotSent\") {\n        value.status.status = \"Requested\";\n        allMessages.push(value.message);\n        continue;\n      }\n      if (value.message.type === \"Mutation\") {\n        allMessages.push(value.message);\n      } else {\n        this.inflightRequests.delete(requestId);\n        this.requestsOlderThanRestart.delete(requestId);\n        if (value.status.status === \"Completed\") {\n          throw new Error(\"Action should never be in 'Completed' state\");\n        }\n        value.status.onResult({\n          success: false,\n          errorMessage: \"Connection lost while action was in flight\",\n          logLines: []\n        });\n      }\n    }\n    return allMessages;\n  }\n  resume() {\n    const allMessages = [];\n    for (const [, value] of this.inflightRequests) {\n      if (value.status.status === \"NotSent\") {\n        value.status.status = \"Requested\";\n        allMessages.push(value.message);\n        continue;\n      }\n    }\n    return allMessages;\n  }\n  /**\n   * @returns true if there are any requests that have been requested but have\n   * not be completed yet.\n   */\n  hasIncompleteRequests() {\n    for (const requestInfo of this.inflightRequests.values()) {\n      if (requestInfo.status.status === \"Requested\") {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * @returns true if there are any inflight requests, including ones that have\n   * completed on the server, but have not been applied.\n   */\n  hasInflightRequests() {\n    return this.inflightRequests.size > 0;\n  }\n  /**\n   * @returns true if there are any inflight requests, that have been hanging around\n   * since prior to the most recent restart.\n   */\n  hasSyncedPastLastReconnect() {\n    return this.requestsOlderThanRestart.size === 0;\n  }\n  timeOfOldestInflightRequest() {\n    if (this.inflightRequests.size === 0) {\n      return null;\n    }\n    let oldestInflightRequest = Date.now();\n    for (const request of this.inflightRequests.values()) {\n      if (request.status.status !== \"Completed\") {\n        if (request.status.requestedAt.getTime() < oldestInflightRequest) {\n          oldestInflightRequest = request.status.requestedAt.getTime();\n        }\n      }\n    }\n    return new Date(oldestInflightRequest);\n  }\n}","map":{"version":3,"names":["jsonToConvex","logToConsole","RequestManager","constructor","__publicField","inflightRequests","Map","requestsOlderThanRestart","Set","request","message","sent","result","Promise","resolve","status","set","requestId","requestedAt","Date","onResult","onResponse","response","requestInfo","get","udfType","type","udfPath","line","logLines","onResolve","success","value","errorMessage","errorData","delete","ts","removeCompleted","completeRequests","entries","lessThanOrEqual","add","restart","keys","allMessages","push","Error","resume","hasIncompleteRequests","values","hasInflightRequests","size","hasSyncedPastLastReconnect","timeOfOldestInflightRequest","oldestInflightRequest","now","getTime"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/browser/sync/request_manager.ts"],"sourcesContent":["import { jsonToConvex } from \"../../values/index.js\";\nimport { logToConsole } from \"../logging.js\";\nimport { Long } from \"../long.js\";\nimport { FunctionResult } from \"./function_result.js\";\nimport {\n  ActionRequest,\n  ActionResponse,\n  ClientMessage,\n  MutationRequest,\n  MutationResponse,\n  RequestId,\n} from \"./protocol.js\";\n\ntype RequestStatus =\n  | {\n      status: \"Requested\" | \"NotSent\";\n      onResult: (result: FunctionResult) => void;\n      requestedAt: Date;\n    }\n  | {\n      status: \"Completed\";\n      onResolve: () => void;\n      ts: Long;\n    };\n\nexport class RequestManager {\n  private inflightRequests: Map<\n    RequestId,\n    {\n      message: MutationRequest | ActionRequest;\n      status: RequestStatus;\n    }\n  >;\n  private requestsOlderThanRestart: Set<RequestId>;\n  constructor() {\n    this.inflightRequests = new Map();\n    this.requestsOlderThanRestart = new Set();\n  }\n\n  request(\n    message: MutationRequest | ActionRequest,\n    sent: boolean,\n  ): Promise<FunctionResult> {\n    const result = new Promise<FunctionResult>((resolve) => {\n      const status = sent ? \"Requested\" : \"NotSent\";\n      this.inflightRequests.set(message.requestId, {\n        message,\n        status: { status, requestedAt: new Date(), onResult: resolve },\n      });\n    });\n\n    return result;\n  }\n\n  /**\n   * Update the state after receiving a response.\n   *\n   * @returns A RequestId if the request is complete and its optimistic update\n   * can be dropped, null otherwise.\n   */\n  onResponse(response: MutationResponse | ActionResponse): RequestId | null {\n    const requestInfo = this.inflightRequests.get(response.requestId);\n    if (requestInfo === undefined) {\n      // Annoyingly we can occasionally get responses to mutations that we're no\n      // longer tracking. One flow where this happens is:\n      // 1. Client sends mutation 1\n      // 2. Client gets response for mutation 1. The sever says that it was committed at ts=10.\n      // 3. Client is disconnected\n      // 4. Client reconnects and re-issues queries and this mutation.\n      // 5. Server sends transition message to ts=20\n      // 6. Client drops mutation because it's already been observed.\n      // 7. Client receives a second response for mutation 1 but doesn't know about it anymore.\n\n      // The right fix for this is probably to add a reconciliation phase on\n      // reconnection where we receive responses to all the mutations before\n      // the transition message so this flow could never happen (CX-1513).\n\n      // For now though, we can just ignore this message.\n      return null;\n    }\n\n    // Because `.restart()` re-requests completed requests, we may get some\n    // responses for requests that are already in the \"Completed\" state.\n    // We can safely ignore those because we've already notified the UI about\n    // their results.\n    if (requestInfo.status.status === \"Completed\") {\n      return null;\n    }\n\n    const udfType =\n      requestInfo.message.type === \"Mutation\" ? \"mutation\" : \"action\";\n    const udfPath = requestInfo.message.udfPath;\n\n    for (const line of response.logLines) {\n      logToConsole(\"info\", udfType, udfPath, line);\n    }\n\n    const status = requestInfo.status;\n    let onResolve;\n    if (response.success) {\n      onResolve = () =>\n        status.onResult({\n          success: true,\n          logLines: response.logLines,\n          value: jsonToConvex(response.result),\n        });\n    } else {\n      const errorMessage = response.result as string;\n      const { errorData } = response;\n      logToConsole(\"error\", udfType, udfPath, errorMessage);\n      onResolve = () =>\n        status.onResult({\n          success: false,\n          errorMessage,\n          errorData:\n            errorData !== undefined ? jsonToConvex(errorData) : undefined,\n          logLines: response.logLines,\n        });\n    }\n\n    // We can resolve Mutation failures immediately since they don't have any\n    // side effects. Actions are intentionally decoupled from\n    // queries/mutations here on the sync protocol since they have different\n    // guarantees.\n    if (response.type === \"ActionResponse\" || !response.success) {\n      onResolve();\n      this.inflightRequests.delete(response.requestId);\n      this.requestsOlderThanRestart.delete(response.requestId);\n      return response.requestId;\n    }\n\n    // We have to wait to resolve the request promise until after we transition\n    // past this timestamp so clients can read their own writes.\n    requestInfo.status = {\n      status: \"Completed\",\n      ts: response.ts,\n      onResolve,\n    };\n\n    return null;\n  }\n\n  // Remove and returns completed requests.\n  removeCompleted(ts: Long): Set<RequestId> {\n    const completeRequests: Set<RequestId> = new Set();\n    for (const [requestId, requestInfo] of this.inflightRequests.entries()) {\n      const status = requestInfo.status;\n      if (status.status === \"Completed\" && status.ts.lessThanOrEqual(ts)) {\n        status.onResolve();\n        completeRequests.add(requestId);\n        this.inflightRequests.delete(requestId);\n        this.requestsOlderThanRestart.delete(requestId);\n      }\n    }\n    return completeRequests;\n  }\n\n  restart(): ClientMessage[] {\n    // When we reconnect to the backend, re-request all requests that are safe\n    // to be resend.\n\n    this.requestsOlderThanRestart = new Set(this.inflightRequests.keys());\n    const allMessages = [];\n    for (const [requestId, value] of this.inflightRequests) {\n      if (value.status.status === \"NotSent\") {\n        value.status.status = \"Requested\";\n        allMessages.push(value.message);\n        continue;\n      }\n\n      if (value.message.type === \"Mutation\") {\n        // This includes ones that have already been completed because we still\n        // want to tell the backend to transition the client past the completed\n        // timestamp. This is safe since mutations are idempotent.\n        allMessages.push(value.message);\n      } else {\n        // Unlike mutations, actions are not idempotent. When we reconnect to the\n        // backend, we don't know if it is safe to resend in-flight actions, so we\n        // cancel them and consider them failed.\n        this.inflightRequests.delete(requestId);\n        this.requestsOlderThanRestart.delete(requestId);\n        if (value.status.status === \"Completed\") {\n          throw new Error(\"Action should never be in 'Completed' state\");\n        }\n        value.status.onResult({\n          success: false,\n          errorMessage: \"Connection lost while action was in flight\",\n          logLines: [],\n        });\n      }\n    }\n    return allMessages;\n  }\n\n  resume(): ClientMessage[] {\n    const allMessages = [];\n    for (const [, value] of this.inflightRequests) {\n      if (value.status.status === \"NotSent\") {\n        value.status.status = \"Requested\";\n        allMessages.push(value.message);\n        continue;\n      }\n    }\n    return allMessages;\n  }\n\n  /**\n   * @returns true if there are any requests that have been requested but have\n   * not be completed yet.\n   */\n  hasIncompleteRequests(): boolean {\n    for (const requestInfo of this.inflightRequests.values()) {\n      if (requestInfo.status.status === \"Requested\") {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @returns true if there are any inflight requests, including ones that have\n   * completed on the server, but have not been applied.\n   */\n  hasInflightRequests(): boolean {\n    return this.inflightRequests.size > 0;\n  }\n\n  /**\n   * @returns true if there are any inflight requests, that have been hanging around\n   * since prior to the most recent restart.\n   */\n  hasSyncedPastLastReconnect(): boolean {\n    return this.requestsOlderThanRestart.size === 0;\n  }\n\n  timeOfOldestInflightRequest(): Date | null {\n    if (this.inflightRequests.size === 0) {\n      return null;\n    }\n    let oldestInflightRequest = Date.now();\n    for (const request of this.inflightRequests.values()) {\n      if (request.status.status !== \"Completed\") {\n        if (request.status.requestedAt.getTime() < oldestInflightRequest) {\n          oldestInflightRequest = request.status.requestedAt.getTime();\n        }\n      }\n    }\n    return new Date(oldestInflightRequest);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}