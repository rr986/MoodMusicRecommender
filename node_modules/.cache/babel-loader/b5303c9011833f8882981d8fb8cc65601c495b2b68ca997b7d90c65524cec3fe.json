{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { getFunctionName } from \"../../server/api.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { createHybridErrorStacktrace, forwardData } from \"../logging.js\";\nimport { canonicalizeUdfPath, serializePathAndArgs } from \"./udf_path_utils.js\";\nimport { ConvexError } from \"../../values/errors.js\";\nclass OptimisticLocalStoreImpl {\n  constructor(queryResults) {\n    // A references of the query results in OptimisticQueryResults\n    __publicField(this, \"queryResults\");\n    // All of the queries modified by this class\n    __publicField(this, \"modifiedQueries\");\n    this.queryResults = queryResults;\n    this.modifiedQueries = [];\n  }\n  getQuery(query) {\n    const queryArgs = parseArgs(arguments.length <= 1 ? undefined : arguments[1]);\n    const name = getFunctionName(query);\n    const queryResult = this.queryResults.get(serializePathAndArgs(name, queryArgs));\n    if (queryResult === void 0) {\n      return void 0;\n    }\n    return OptimisticLocalStoreImpl.queryValue(queryResult.result);\n  }\n  getAllQueries(query) {\n    const queriesWithName = [];\n    const name = getFunctionName(query);\n    for (const queryResult of this.queryResults.values()) {\n      if (queryResult.udfPath === canonicalizeUdfPath(name)) {\n        queriesWithName.push({\n          args: queryResult.args,\n          value: OptimisticLocalStoreImpl.queryValue(queryResult.result)\n        });\n      }\n    }\n    return queriesWithName;\n  }\n  setQuery(queryReference, args, value) {\n    const queryArgs = parseArgs(args);\n    const name = getFunctionName(queryReference);\n    const queryToken = serializePathAndArgs(name, queryArgs);\n    let result;\n    if (value === void 0) {\n      result = void 0;\n    } else {\n      result = {\n        success: true,\n        value,\n        // It's an optimistic update, so there are no function logs to show.\n        logLines: []\n      };\n    }\n    const query = {\n      udfPath: name,\n      args: queryArgs,\n      result\n    };\n    this.queryResults.set(queryToken, query);\n    this.modifiedQueries.push(queryToken);\n  }\n  static queryValue(result) {\n    if (result === void 0) {\n      return void 0;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      return void 0;\n    }\n  }\n}\nexport class OptimisticQueryResults {\n  constructor() {\n    __publicField(this, \"queryResults\");\n    __publicField(this, \"optimisticUpdates\");\n    this.queryResults = /* @__PURE__ */new Map();\n    this.optimisticUpdates = [];\n  }\n  ingestQueryResultsFromServer(serverQueryResults, optimisticUpdatesToDrop) {\n    this.optimisticUpdates = this.optimisticUpdates.filter(updateAndId => {\n      return !optimisticUpdatesToDrop.has(updateAndId.mutationId);\n    });\n    const oldQueryResults = this.queryResults;\n    this.queryResults = new Map(serverQueryResults);\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    for (const updateAndId of this.optimisticUpdates) {\n      updateAndId.update(localStore);\n    }\n    const changedQueries = [];\n    for (const [queryToken, query] of this.queryResults) {\n      const oldQuery = oldQueryResults.get(queryToken);\n      if (oldQuery === void 0 || oldQuery.result !== query.result) {\n        changedQueries.push(queryToken);\n      }\n    }\n    return changedQueries;\n  }\n  applyOptimisticUpdate(update, mutationId) {\n    this.optimisticUpdates.push({\n      update,\n      mutationId\n    });\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    update(localStore);\n    return localStore.modifiedQueries;\n  }\n  queryResult(queryToken) {\n    const query = this.queryResults.get(queryToken);\n    if (query === void 0) {\n      return void 0;\n    }\n    const result = query.result;\n    if (result === void 0) {\n      return void 0;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      if (result.errorData !== void 0) {\n        throw forwardData(result, new ConvexError(createHybridErrorStacktrace(\"query\", query.udfPath, result)));\n      }\n      throw new Error(createHybridErrorStacktrace(\"query\", query.udfPath, result));\n    }\n  }\n  hasQueryResult(queryToken) {\n    return this.queryResults.get(queryToken) !== void 0;\n  }\n  /**\n   * @internal\n   */\n  queryLogs(queryToken) {\n    const query = this.queryResults.get(queryToken);\n    return query?.result?.logLines;\n  }\n}","map":{"version":3,"names":["getFunctionName","parseArgs","createHybridErrorStacktrace","forwardData","canonicalizeUdfPath","serializePathAndArgs","ConvexError","OptimisticLocalStoreImpl","constructor","queryResults","__publicField","modifiedQueries","getQuery","query","queryArgs","arguments","length","undefined","name","queryResult","get","queryValue","result","getAllQueries","queriesWithName","values","udfPath","push","args","value","setQuery","queryReference","queryToken","success","logLines","set","OptimisticQueryResults","Map","optimisticUpdates","ingestQueryResultsFromServer","serverQueryResults","optimisticUpdatesToDrop","filter","updateAndId","has","mutationId","oldQueryResults","localStore","update","changedQueries","oldQuery","applyOptimisticUpdate","errorData","Error","hasQueryResult","queryLogs"],"sources":["/Users/Ragini/Movies/MoodMusicRecommender/node_modules/convex/src/browser/sync/optimistic_updates_impl.ts"],"sourcesContent":["import {\n  FunctionArgs,\n  FunctionReference,\n  FunctionReturnType,\n  OptionalRestArgs,\n  getFunctionName,\n} from \"../../server/api.js\";\nimport { parseArgs } from \"../../common/index.js\";\nimport { Value } from \"../../values/index.js\";\nimport { createHybridErrorStacktrace, forwardData } from \"../logging.js\";\nimport { FunctionResult } from \"./function_result.js\";\nimport { OptimisticLocalStore } from \"./optimistic_updates.js\";\nimport { RequestId } from \"./protocol.js\";\nimport {\n  canonicalizeUdfPath,\n  QueryToken,\n  serializePathAndArgs,\n} from \"./udf_path_utils.js\";\nimport { ConvexError } from \"../../values/errors.js\";\n\n/**\n * An optimistic update function that has been curried over its arguments.\n */\ntype WrappedOptimisticUpdate = (locaQueryStore: OptimisticLocalStore) => void;\n\n/**\n * The implementation of `OptimisticLocalStore`.\n *\n * This class provides the interface for optimistic updates to modify query results.\n */\nclass OptimisticLocalStoreImpl implements OptimisticLocalStore {\n  // A references of the query results in OptimisticQueryResults\n  private readonly queryResults: QueryResultsMap;\n\n  // All of the queries modified by this class\n  readonly modifiedQueries: QueryToken[];\n\n  constructor(queryResults: QueryResultsMap) {\n    this.queryResults = queryResults;\n    this.modifiedQueries = [];\n  }\n\n  getQuery<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    ...args: OptionalRestArgs<Query>\n  ): undefined | FunctionReturnType<Query> {\n    const queryArgs = parseArgs(args[0]);\n    const name = getFunctionName(query);\n    const queryResult = this.queryResults.get(\n      serializePathAndArgs(name, queryArgs),\n    );\n    if (queryResult === undefined) {\n      return undefined;\n    }\n    return OptimisticLocalStoreImpl.queryValue(queryResult.result);\n  }\n\n  getAllQueries<Query extends FunctionReference<\"query\">>(\n    query: Query,\n  ): {\n    args: FunctionArgs<Query>;\n    value: undefined | FunctionReturnType<Query>;\n  }[] {\n    const queriesWithName: {\n      args: FunctionArgs<Query>;\n      value: undefined | FunctionReturnType<Query>;\n    }[] = [];\n    const name = getFunctionName(query);\n    for (const queryResult of this.queryResults.values()) {\n      if (queryResult.udfPath === canonicalizeUdfPath(name)) {\n        queriesWithName.push({\n          args: queryResult.args as FunctionArgs<Query>,\n          value: OptimisticLocalStoreImpl.queryValue(queryResult.result),\n        });\n      }\n    }\n    return queriesWithName;\n  }\n\n  setQuery<QueryReference extends FunctionReference<\"query\">>(\n    queryReference: QueryReference,\n    args: FunctionArgs<QueryReference>,\n    value: undefined | FunctionReturnType<QueryReference>,\n  ): void {\n    const queryArgs = parseArgs(args);\n    const name = getFunctionName(queryReference);\n    const queryToken = serializePathAndArgs(name, queryArgs);\n\n    let result: FunctionResult | undefined;\n    if (value === undefined) {\n      result = undefined;\n    } else {\n      result = {\n        success: true,\n        value,\n        // It's an optimistic update, so there are no function logs to show.\n        logLines: [],\n      };\n    }\n    const query: Query = {\n      udfPath: name,\n      args: queryArgs,\n      result,\n    };\n    this.queryResults.set(queryToken, query);\n    this.modifiedQueries.push(queryToken);\n  }\n\n  private static queryValue(\n    result: FunctionResult | undefined,\n  ): Value | undefined {\n    if (result === undefined) {\n      return undefined;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      // If the query is an error state, just return `undefined` as though\n      // it's loading. Optimistic updates should already handle `undefined` well\n      // and there isn't a need to break the whole update because it tried\n      // to load a single query that errored.\n      return undefined;\n    }\n  }\n}\n\ntype OptimisticUpdateAndId = {\n  update: WrappedOptimisticUpdate;\n  mutationId: RequestId;\n};\n\ntype Query = {\n  // undefined means the query was set to be loading (undefined) in an optimistic update.\n  // Note that we can also have queries not present in the QueryResultMap\n  // at all because they are still loading from the server.\n  result: FunctionResult | undefined;\n  udfPath: string;\n  args: Record<string, Value>;\n};\nexport type QueryResultsMap = Map<QueryToken, Query>;\n\ntype ChangedQueries = QueryToken[];\n\n/**\n * A view of all of our query results with optimistic updates applied on top.\n */\nexport class OptimisticQueryResults {\n  private queryResults: QueryResultsMap;\n  private optimisticUpdates: OptimisticUpdateAndId[];\n\n  constructor() {\n    this.queryResults = new Map();\n    this.optimisticUpdates = [];\n  }\n\n  ingestQueryResultsFromServer(\n    serverQueryResults: QueryResultsMap,\n    optimisticUpdatesToDrop: Set<RequestId>,\n  ): ChangedQueries {\n    this.optimisticUpdates = this.optimisticUpdates.filter((updateAndId) => {\n      return !optimisticUpdatesToDrop.has(updateAndId.mutationId);\n    });\n\n    const oldQueryResults = this.queryResults;\n    this.queryResults = new Map(serverQueryResults);\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    for (const updateAndId of this.optimisticUpdates) {\n      updateAndId.update(localStore);\n    }\n\n    // To find the changed queries, just do a shallow comparison\n    // TODO(CX-733): Change this so we avoid unnecessary rerenders\n    const changedQueries: ChangedQueries = [];\n    for (const [queryToken, query] of this.queryResults) {\n      const oldQuery = oldQueryResults.get(queryToken);\n      if (oldQuery === undefined || oldQuery.result !== query.result) {\n        changedQueries.push(queryToken);\n      }\n    }\n\n    return changedQueries;\n  }\n\n  applyOptimisticUpdate(\n    update: WrappedOptimisticUpdate,\n    mutationId: RequestId,\n  ): ChangedQueries {\n    // Apply the update to our store\n    this.optimisticUpdates.push({\n      update,\n      mutationId,\n    });\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    update(localStore);\n\n    // Notify about any query results that changed\n    // TODO(CX-733): Change this so we avoid unnecessary rerenders\n    return localStore.modifiedQueries;\n  }\n\n  queryResult(queryToken: QueryToken): Value | undefined {\n    const query = this.queryResults.get(queryToken);\n    if (query === undefined) {\n      return undefined;\n    }\n    const result = query.result;\n    if (result === undefined) {\n      return undefined;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      if (result.errorData !== undefined) {\n        throw forwardData(\n          result,\n          new ConvexError(\n            createHybridErrorStacktrace(\"query\", query.udfPath, result),\n          ),\n        );\n      }\n      throw new Error(\n        createHybridErrorStacktrace(\"query\", query.udfPath, result),\n      );\n    }\n  }\n\n  hasQueryResult(queryToken: QueryToken): boolean {\n    return this.queryResults.get(queryToken) !== undefined;\n  }\n\n  /**\n   * @internal\n   */\n  queryLogs(queryToken: QueryToken): string[] | undefined {\n    const query = this.queryResults.get(queryToken);\n    return query?.result?.logLines;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}